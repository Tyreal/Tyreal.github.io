<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="We have a long way to go">
<meta property="og:type" content="website">
<meta property="og:title" content="HUI BLOG">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="HUI BLOG">
<meta property="og:description" content="We have a long way to go">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="HUI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HUI BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HUI BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/18/C++STL_1_introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/18/C++STL_1_introduce/" class="post-title-link" itemprop="url">C++ STL 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-18 11:32:45" itemprop="dateCreated datePublished" datetime="2023-07-18T11:32:45+08:00">2023-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-23 10:25:31" itemprop="dateModified" datetime="2023-07-23T10:25:31+08:00">2023-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STL标准库"><a href="#STL标准库" class="headerlink" title="STL标准库"></a>STL标准库</h1><p><strong>1. 标准库与STL</strong></p>
<ul>
<li><p>标准库</p>
<p>  标准库包含STL，STL包含了6大部件</p>
<ul>
<li><p>标准库以 <strong>header files</strong> 形式存在，不带文档名**.h**</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原有C语言中的<strong>C headers files</strong>不带**.h**</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">// 表示c库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>新式headers内组件封装在namespace std;</p>
</li>
</ul>
</li>
<li><p>常用网站</p>
<ul>
<li>CPlusPlus.com</li>
<li>CppReference.com</li>
<li>gcc.gnu.org</li>
</ul>
</li>
</ul>
<p><strong>2. STL体系结构基础</strong></p>
<ul>
<li><p>六大组件</p>
<ul>
<li><p>容器<br>  容器储存操作数据</p>
</li>
<li><p>分配器<br>  解决内存分配问题</p>
</li>
<li><p>算法<br>  基于容器上的算法</p>
</li>
<li><p>迭代器<br>  泛化指针，用于数据指针访问</p>
</li>
<li><p>适配器<br>  实现不同适配器的转换，类似于“变压器”</p>
</li>
<li><p>仿函数</p>
<ul>
<li><p><strong>notes</strong></p>
<ul>
<li>数据存储类（容器）与数据操作类（算法）分开，并不符合面向对象的一般原则（数据存储与数据操作被封装到同一个类中）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>demo</strong><br>- <strong>notes</strong><br><br>- 不同的容器需要包含对应的头文件<br>  - 容器第二个模板参数是分配器，有默认分配器<br>      <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line"> - allocator&lt;<span class="type">int</span>&gt;</span><br><span class="line">  	<span class="type">int</span> 类型的分配器</span><br></pre></td></tr></table></figure><br>  - 算法对容器进行操作<br><br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(),<span class="number">40</span>)))</span><br><span class="line">      </span><br><span class="line">       - 统计小于<span class="number">40</span>的个数</span><br><span class="line">       - count_if是算法接口</span><br><span class="line">       - vi.<span class="built_in">begin</span>() 是迭代器，算法支持传入容器的迭代器，对元素进行操作</span><br><span class="line">       - <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(),<span class="number">40</span>)) </span><br><span class="line">       </span><br><span class="line">       	- 整个语句可以表达: 判断满足（不小于<span class="number">40</span>），则是。。。</span><br><span class="line">	- <span class="built_in">bind2nd</span>() 函数适配器，绑定第二参数</span><br><span class="line">- <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;() 函数对象</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
</li>
<li><p>容器内元素的迭代访问</p>
<ul>
<li><p>容器访问的前闭后开区间</p>
<ul>
<li><strong>notes</strong><ul>
<li>begin() 指向第一个元素</li>
<li>end() 指向最后一个元素的下一个元素</li>
<li>Container<T> 表明一个容器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>range-based 表达式（C++11）</p>
<ul>
<li><strong>notes</strong><ul>
<li>coll 表示容器对象</li>
<li>auto 自动推导类型，但是程序员自己必须知道类型</li>
<li>auto&amp; 表示引用，即对容器元素本身进行操作</li>
</ul>
</li>
</ul>
</li>
<li><p>auto的使用技巧</p>
<ul>
<li><p>使用 auto 防止冗长的迭代器声明</p>
<ul>
<li><strong>notes</strong></li>
</ul>
</li>
<li><p>ite 类型能够被自动推导</p>
</li>
</ul>
</li>
</ul>
<p><strong>2. 容器之分类与测试</strong></p>
<ul>
<li><p>结构与分类</p>
<ul>
<li><p>序列式容器</p>
<ul>
<li><p>Array</p>
<p> 固定大小的连续内存数组  </p>
</li>
<li><p>Vector	</p>
<p>  只允许从后面进行动态扩容的数组（连续内存）</p>
</li>
<li><p>deque</p>
<p>  队列、双向队列</p>
</li>
<li><p>List</p>
<p>  双向链表</p>
</li>
<li><p>Forward-List</p>
<p>  单向链表</p>
</li>
</ul>
</li>
<li><p>关联式容器</p>
<p>  用于快速查找，基于红黑树（高度平衡二叉树）实现的二分查找树，Multi是允许放入重复元素的</p>
<ul>
<li><p>Set&#x2F;MultiSet</p>
<p>  Set的单个节点仅保存key</p>
</li>
<li><p>Map&#x2F;Multimap    </p>
<p>  Map的单个节点保存了：key和value</p>
</li>
</ul>
</li>
<li><p>无序容器（C++11）</p>
<p>  其实也是关联式容器的一种，基于hash table做的</p>
<ul>
<li><p><strong>notes</strong></p>
</li>
<li><p>单链式结构实现</p>
</li>
<li><p>不同的元素通过hashFunc计算出不同的索引，根据这个索引可以快速获取该元素</p>
<ul>
<li><p>不同元素计算的hashFunc索引相同，即出现碰撞，单向链表是用来解决，保证出现碰撞元素仍然出于相同索引的位置</p>
</li>
<li><p><strong>notes</strong></p>
</li>
<li><p>红色标记为 C++11 新增</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>容器测试<strong>笔记</strong></p>
<ul>
<li><p>代码规范</p>
<ul>
<li>将测试函数使用namespace区分</li>
<li>变量定义不缩进与执行流程缩进，方便区分</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>(); <span class="comment">// 变量定义不缩进</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;<span class="comment">// 执行语句缩进</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于测试程序要考虑到测试陷阱</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;p.<span class="built_in">what</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">absort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊语法</p>
<ul>
<li><p>::从全局查找变量函数</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">find</span>(); <span class="comment">// 调用全局的find函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局Sort函数以及容器自身的Sort函数选择</p>
<p>  优先使用容器自身的Sort函数</p>
</li>
<li><p>查找函数</p>
<ul>
<li>find 顺序查找</li>
<li>bsearch 二分查找（前提必须排序）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>vector</p>
<ul>
<li><strong>capacity</strong> 2倍增长</li>
</ul>
</li>
<li><p>list</p>
<ul>
<li>存在最大容量的限制</li>
</ul>
</li>
<li><p>forward_list</p>
<ul>
<li>只能通过front从头插入元素</li>
<li>与C中扩展的slist功能相同</li>
</ul>
</li>
<li><p>deque</p>
<ul>
<li><p>buffer特点 <strong>分段连续</strong></p>
<p>物理上，段与段之间不连续，段内连续</p>
</li>
<li><p>每次会扩充一个buffer size</p>
</li>
<li><p>技术上的适配器</p>
<p>  即通过deque的功能进行选择实现的容器</p>
<ul>
<li><p>stack</p>
<p>  不提供iterater</p>
<p>  从一端进出元素</p>
</li>
<li><p>queue</p>
<p>不提供iterater</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>含有multi的关联式容器（允许重复）            </p>
<ul>
<li><p>multiset</p>
<p>  基于红黑树的底层实现</p>
</li>
<li><p>multimap</p>
<p>  基于红黑树的底层实现</p>
<p>  基于pair&lt;key,value&gt;的键值对</p>
</li>
<li><p>unordered_multiset</p>
<p>  基于hash table实现</p>
<ul>
<li>每个bucket放入一个单向链表，往往bucket数量大于元素数量</li>
<li>当元素数量接近bucket个数是，bucket将进行扩充，元素重新映射到bucket中</li>
</ul>
</li>
</ul>
</li>
<li><p>含有multi的关联式容器 </p>
<ul>
<li><p>set</p>
</li>
<li><p>map</p>
<p>  支持索引</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i] = <span class="built_in">string</span>(buf); <span class="comment">// 这里将 (i,string(buf)) 组成 pair </span></span><br></pre></td></tr></table></figure></li>
<li><p>unordered_set</p>
</li>
</ul>
</li>
</ul>
<p><strong>2. 分配器与测试</strong>   </p>
<ul>
<li><p>建议</p>
<ul>
<li><p>尽可能通过容器获取数据内存，而不是通过allocator</p>
<p>  因为allocator需要保证<strong>分配与销毁数量相同</strong></p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/20/C++%20Primer%20Chapter%2019%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/20/C++%20Primer%20Chapter%2019%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 19 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-20 17:56:32" itemprop="dateCreated datePublished" datetime="2023-06-20T17:56:32+08:00">2023-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-24 10:49:28" itemprop="dateModified" datetime="2023-06-24T10:49:28+08:00">2023-06-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第19章-特殊工具与技术"><a href="#第19章-特殊工具与技术" class="headerlink" title="第19章 特殊工具与技术"></a>第19章 特殊工具与技术</h1><h2 id="控制内存分配"><a href="#控制内存分配" class="headerlink" title="控制内存分配"></a>控制内存分配</h2><h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载<code>new</code>和<code>delete</code></h3><p>使用<code>new</code>表达式时，实际执行了三步操作：</p>
<ul>
<li><p><code>new</code>表达式调用名为<code>operator new</code>（或<code>operator new[]</code>）的标准库函数。该函数分配一块足够大、原始、未命名的内存空间以便存储特定类型的对象（或对象数组）。</p>
</li>
<li><p>编译器调用对应的构造函数构造这些对象并初始化。</p>
</li>
<li><p>对象被分配了空间并构造完成，返回指向该对象的指针。</p>
</li>
</ul>
<p>使用<code>delete</code>表达式时，实际执行了两步操作：</p>
<ul>
<li><p>对指针所指向的对象（或对象数组）执行对应的析构函数。</p>
</li>
<li><p>编译器调用名为<code>operator delete</code>（或<code>operator delete[]</code>）的标准库函数释放内存空间。</p>
</li>
</ul>
<p>程序可以在全局作用域中定义<code>operator new</code>和<code>operator delete</code>函数，也可以将其定义为成员函数。编译器发现<code>new</code>或<code>delete</code>表达式后，将在程序中查找可供调用的<code>operator</code>函数。</p>
<p>可以使用作用域运算符令<code>new</code>或<code>delete</code>表达式忽略定义在类中的函数，直接执行全局作用域版本。</p>
<p><code>nothrow_t</code>类型是定义在头文件<code>new</code>中的一个结构体，这个类型不包含任何成员。头文件<code>new</code>还定义了一个名为<code>nothrow</code>的<code>const</code>对象，用户可以通过这个对象请求<code>new</code>的非抛出版本。</p>
<p>将<code>operator</code>函数定义为类的成员时，它们是隐式静态的，无须显式地声明<code>static</code>。</p>
<p><code>operator new</code>和<code>operator new[]</code>函数的返回类型必须是<code>void*</code>，第一个形参的类型必须是<code>size_t</code>且不能有默认实参。编译器调用<code>operator new</code>时，用存储指定类型对象所需的字节数初始化<code>size_t</code>形参；调用<code>operator new[]</code>时，传入函数的则是存储数组中所有元素所需的空间。</p>
<p>自定义<code>operator new</code>函数时可以为它提供额外的形参，用到这些自定义函数的<code>new</code>表达式必须使用<code>new</code>的定位形式传递参数。下面这种形式的<code>new</code>函数只供标准库使用，不能被用户重定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span>*)</span></span>;   </span><br></pre></td></tr></table></figure>

<p><code>operator delete</code>和<code>operator delete[]</code>函数的返回类型必须是<code>void</code>，第一个形参的类型必须是<code>void*</code>。函数被调用时，编译器会用指向待释放内存的指针来初始化<code>void*</code>形参。</p>
<p>将<code>operator delete</code>或<code>operator delete[]</code>定义为类的成员时，可以包含另一个类型为<code>size_t</code>的形参。该形参的初始值是第一个形参所指向对象的字节数。</p>
<p><code>malloc</code>函数接受一个表示待分配字节数的<code>size_t</code>参数，返回指向分配空间的指针，或者返回0以表示分配失败。<code>free</code>函数接受一个<code>void*</code>参数，它是<code>malloc</code>返回的指针的副本，<code>free</code>将相关内存返回给系统。调用<code>free(0)</code>没有任何意义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">void</span> *mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *mem)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位<code>new</code>表达式</h3><p>在C++的早期版本中，<code>allocator</code>类还不是标准库的一部分。如果程序想分开内存分配和初始化过程，需要直接调用<code>operator new</code>和<code>operator delete</code>函数。它们类似<code>allocator</code>类的<code>allocate</code>和<code>deallocate</code>成员，负责分配或释放内存空间，但不会构造或销毁对象。</p>
<p>不能使用<code>allocator</code>类的<code>construct</code>函数在<code>operator new</code>分配的内存空间中构造对象，而应该使用定位<code>new</code>表达式构造。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="built_in">new</span> (place_address) <span class="built_in">type</span> (initializers)</span><br><span class="line"><span class="built_in">new</span> (place_address) type [size]</span><br><span class="line"><span class="built_in">new</span> (place_address) type [size] &#123; braced initializer list &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>place_address</code>是一个指针。<code>initializers</code>是一个以逗号分隔的初始值列表（可能为空），该列表用于构造新分配的对象。</p>
<p>当仅通过一个地址值调用定位<code>new</code>时，它会使用<code>operator new(size_t, void*)</code>函数（用户无法重载的版本）。该函数不分配任何内存，直接返回指针形参。然后由<code>new</code>表达式负责在指定的地址初始化对象。</p>
<p>传递给<code>construct</code>函数的指针必须指向同一个<code>allocator</code>对象分配的空间，但是传递给定位<code>new</code>的指针无须指向<code>operator new</code>分配的内存，甚至不需要指向动态内存。</p>
<p>调用析构函数会销毁对象，但不会释放内存。如果需要的话，可以重新使用该空间。</p>
<h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><p>运行时类型识别（RTTI）的功能由两个运算符实现：</p>
<ul>
<li><p><code>typeid</code>运算符，用于返回表达式的类型。</p>
</li>
<li><p><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。</p>
</li>
</ul>
<p>RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。</p>
<h3 id="dynamic-cast运算符"><a href="#dynamic-cast运算符" class="headerlink" title="dynamic_cast运算符"></a><code>dynamic_cast</code>运算符</h3><p><code>dynamic_cast</code>运算符的形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)</span><br></pre></td></tr></table></figure>

<p>其中<code>type</code>是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，<code>e</code>必须是一个有效指针；在第二种形式中，<code>e</code>必须是一个左值；在第三种形式中，<code>e</code>不能是左值。在所有形式中，<code>e</code>的类型必须符合以下条件之一：</p>
<ul>
<li><p><code>e</code>是<code>type</code>的公有派生类。</p>
</li>
<li><p><code>e</code>是<code>type</code>的公有基类。</p>
</li>
<li><p><code>e</code>和<code>type</code>类型相同。</p>
</li>
</ul>
<p>如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果：</p>
<ul>
<li><p>如果<code>dynamic_cast</code>语句的转换目标是指针类型，则结果为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived *dp = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(bp))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<code>dynamic_cast</code>语句的转换目标是引用类型，则抛出<code>bad_cast</code>异常（定义在头文件<code>typeinfo</code>中）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Base &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> Derived &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_cast)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在条件判断部分执行<code>dynamic_cast</code>可以确保类型转换和结果检查在同一条表达式中完成。</p>
<p>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</p>
<h3 id="typeid运算符（"><a href="#typeid运算符（" class="headerlink" title="typeid运算符（"></a><code>typeid</code>运算符（</h3><p><code>typeid</code>表达式的形式是<code>typeid(e)</code>，其中<code>e</code>可以是任意表达式或类型名称。<code>typeid</code>的结果是一个指向常量对象的引用，该对象的类型是标准库<code>type_info</code>（定义在头文件<code>typeinfo</code>中）或<code>type_info</code>的公有派生类型。</p>
<p><code>typeid</code>可以作用于任何类型的表达式，其中的顶层<code>const</code>会被忽略。如果表达式是一个引用，则<code>typeid</code>返回该引用所指对象的类型。当<code>typeid</code>作用于数组或函数时，不会执行向指针的标准类型转换。</p>
<p>当<code>typeid</code>的运算对象不属于类类型或者是一个不包含任何虚函数的类时，<code>typeid</code>返回其静态类型。而当运算对象是至少包含一个虚函数的类的左值时，<code>typeid</code>的结果直到运行期间才会确定。</p>
<p>通常情况下，<code>typeid</code>用于比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同。</p>
<p><code>typeid</code>应该作用于对象。当<code>typeid</code>作用于指针时，返回的结果是该指针的静态编译类型。</p>
<h3 id="使用RTTI"><a href="#使用RTTI" class="headerlink" title="使用RTTI"></a>使用RTTI</h3><p>使用RTTI可以为具有继承关系的类实现相等运算符。</p>
<p>相等运算符的形参是基类的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base&amp;, <span class="type">const</span> Base&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用<code>typeid</code>检查两个运算对象的类型是否一致，类型一致才会继续判断每个数据成员的取值是否相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base &amp;lhs, <span class="type">const</span> Base &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">typeid</span>(lhs) == <span class="built_in">typeid</span>(rhs) &amp;&amp; lhs.<span class="built_in">equal</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个类定义的<code>equal</code>函数负责比较类型自己的数据成员。<code>equal</code>函数的形参都是基类的引用，但是在比较之前需要先把运算对象转换成自己的类型。</p>
<h3 id="type-info类"><a href="#type-info类" class="headerlink" title="type_info类"></a><code>type_info</code>类</h3><p><code>type_info</code>类一般是作为一个基类出现，所以它还应该提供一个公有虚析构函数。当编译器希望提供额外的类型信息时，通常在<code>type_info</code>的派生类中完成。</p>
<p><code>type_info</code>类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义为删除的。创建<code>type_info</code>对象的唯一方式就是使用<code>typeid</code>运算符。</p>
<p>对于某种给定类型来说，<code>name</code>成员的返回值因编译器而异并且不一定与在程序中使用的名字一致。对于<code>name</code>返回值的唯一要求就是类型不同则返回的字符串必须有所区别。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>和类一样，每个枚举类型都定义了一种新的类型。枚举属于字面值常量类型。</p>
<p>C++包含两种枚举：</p>
<ul>
<li><p>限定作用域的枚举（scoped enumeration，C++11新增）。定义形式是关键字<code>enum class</code>（或<code>enum struct</code>）后接枚举类型名字以及用花括号包围、以逗号分隔的枚举成员（enumerator）列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">open_modes</span></span><br><span class="line">&#123;</span><br><span class="line">    input,</span><br><span class="line">    output,</span><br><span class="line">    append</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不限定作用域的枚举（unscoped enumeration）。定义时省略关键字<code>class</code>（或<code>struct</code>），枚举类型名字是可选的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C++<span class="comment">// unscoped enumeration</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span></span><br><span class="line">&#123;</span><br><span class="line">    red,</span><br><span class="line">    yellow,</span><br><span class="line">    green</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// unnamed, unscoped enum</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    floatPrec = <span class="number">6</span>,</span><br><span class="line">    doublePrec = <span class="number">10</span>,</span><br><span class="line">    double_doublePrec = <span class="number">10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果枚举是未命名的，则只能在定义该枚举时一同定义它的对象。</p>
</li>
</ul>
<p>在限定作用域的枚举类型中，枚举成员的名字遵循常规作用域规则，并且在枚举类型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同。</p>
<p>默认情况下，枚举值从0开始，依次加1。也可以直接为枚举成员指定特定的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">intTypes</span></span><br><span class="line">&#123;</span><br><span class="line">    charTyp = <span class="number">8</span>, shortTyp = <span class="number">16</span>, intTyp = <span class="number">16</span>,</span><br><span class="line">    longTyp = <span class="number">32</span>, long_longTyp = <span class="number">64</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>枚举值可以不唯一。如果没有显式提供初始值，则当前枚举成员的值等于之前枚举成员的值加1。</p>
<p>枚举成员是<code>const</code>的，因此在初始化枚举成员时提供的初始值必须是常量表达式。</p>
<p>可以在任何需要常量表达式的地方使用枚举成员。如：</p>
<ul>
<li><p>定义枚举类型的<code>constexpr</code>变量。</p>
</li>
<li><p>将枚举类型对象作为<code>switch</code>语句的表达式，而将枚举值作为<code>case</code>标签。</p>
</li>
<li><p>将枚举类型作为非类型模板形参使用。</p>
</li>
<li><p>在类的定义中初始化枚举类型的静态数据成员。</p>
</li>
</ul>
<p>初始化枚举对象或者给枚举对象赋值时，必须使用该类型的一个枚举成员或者该类型的另一个对象。即使某个整型值恰好与枚举成员的值相等，也不能用其初始化枚举对象。</p>
<p>不限定作用域的枚举类型对象或枚举成员能自动转换成整型。</p>
<p>枚举是由某种整数类型表示的。C++11中，可以在枚举名字后面指定用来表示枚举成员的整型类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">intValues</span> : <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果没有指定枚举的潜在类型，则默认情况下限定作用域的枚举成员类型是<code>int</code>。不限定作用域的枚举成员不存在默认类型。</p>
<p>C++11中可以提前声明枚举。枚举的前置声明必须指定（无论隐式或显式）其成员的类型。</p>
<h2 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h2><p>成员指针（pointer to member）是指可以指向类的非静态成员的指针。</p>
<p>成员指针的类型包括类的类型和成员的类型。初始化成员指针时，会令其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。</p>
<h3 id="数据成员指针"><a href="#数据成员指针" class="headerlink" title="数据成员指针"></a>数据成员指针</h3><p>声明成员指针时必须在<code>*</code>前添加<code>classname::</code>以表示当前定义的指针可以指向<code>classname</code>的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get_cursor</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> contents[cursor]; &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string contents;</span><br><span class="line">    pos cursor;</span><br><span class="line">    pos height, width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string Screen::*pdata;</span><br></pre></td></tr></table></figure>

<p>初始化或者给成员指针赋值时，需要指定它所指向的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdata = &amp;Screen::contents;</span><br></pre></td></tr></table></figure>

<p>成员指针使用<code>.*</code>和<code>-&gt;*</code>来获得其指向对象的成员。</p>
<p>常规的访问控制规则对成员指针同样有效。数据成员一般是私有的，因此通常不能直接获得数据成员的指针。如果类希望外部代码能访问它的私有数据成员，可以定义一个函数，令其返回指向私有成员的指针。</p>
<h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><p>类似于其他函数指针，指向成员函数的指针也需要指定目标函数的返回类型和形参列表。如果成员函数是<code>const</code>成员或引用成员，则指针也必须包含<code>const</code>或引用限定符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pmf = &amp;Screen::get_cursor;</span><br></pre></td></tr></table></figure>

<p>如果成员函数存在重载问题，则必须显式声明指针指向的函数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> (Screen::*pmf2)(Screen::pos, Screen::pos) <span class="type">const</span>;</span><br><span class="line">pmf2 = &amp;Screen::get;</span><br></pre></td></tr></table></figure>

<p>和普通函数指针不同，在成员函数和指向该成员的指针之间不存在自动转换规则。</p>
<p>成员函数指针使用<code>.*</code>和<code>-&gt;*</code>来调用类的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="type">char</span> c1 = (pScreen-&gt;*pmf)();</span><br><span class="line"><span class="type">char</span> c2 = (myScreen.*pmf2)(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>可以使用类型别名来增强含有成员指针的代码的可读性。</p>
<h3 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h3><p>成员指针不是一个可调用对象，不支持函数调用运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fp = &amp;string::empty;   </span><br><span class="line"><span class="built_in">find_if</span>(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), fp);</span><br></pre></td></tr></table></figure>

<p>从成员函数指针获取可调用对象的一种方法是使用标准库模板<code>function</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">bool</span> (<span class="type">const</span> string&amp;)&gt; fcn = &amp;string::empty;</span><br><span class="line"><span class="built_in">find_if</span>(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), fcn);</span><br></pre></td></tr></table></figure>

<p>定义一个<code>function</code>对象时，必须指定该对象所能表示的函数类型（即可调用对象的形式）。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个对象上执行的。</p>
<p>使用标准库功能<code>mem_fn</code>（定义在头文件<code>functional</code>中）可以让编译器推断成员的类型。和<code>function</code>一样，<code>mem_fn</code>可以从成员指针生成可调用对象。但<code>mem_fn</code>可以根据成员指针的类型推断可调用对象的类型，无须显式指定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_if</span>(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;string::empty));</span><br></pre></td></tr></table></figure>

<p><code>mem_fn</code>生成的可调用对象可以通过对象和指针调用。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>一个类可以定义在另一个类的内部，前者被称为嵌套类或嵌套类型（nested type）。嵌套类通常用于定义作为实现部分的类。</p>
<p>外层类的对象和嵌套类的对象是相互独立的。在嵌套类对象中不包含任何外层类定义的成员，在外层类对象中也不包含任何嵌套类定义的成员。</p>
<p>嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。</p>
<p>外层类对嵌套类的成员没有特殊的访问权限，嵌套类对外层类的成员也没有特殊的访问权限。</p>
<p>嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类的访问说明符决定。</p>
<p>嵌套类必须声明在类的内部，但是可以定义在类的内部或外部。在外层类之外定义嵌套类时，必须用外层类的名字限定嵌套类的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextQuery</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">QueryResult</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextQuery</span>::QueryResult</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型。</p>
<h2 id="union：一种节省空间的类"><a href="#union：一种节省空间的类" class="headerlink" title="union：一种节省空间的类"></a><code>union</code>：一种节省空间的类</h2><p>联合（union）是一种特殊的类。一个联合可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。给联合的某个成员赋值之后，其他成员会变为未定义状态。分配给联合对象的存储空间至少要能容纳它的最大数据成员。</p>
<p>联合不能包含引用类型的成员。在C++11中，含有构造函数或析构函数的类类型也可以作为联合的成员类型。</p>
<p>联合可以为其成员指定<code>public</code>、<code>protected</code>和<code>private</code>等保护标记。默认情况下，联合的成员都是公有的。</p>
<p>联合可以定义包括构造函数和析构函数在内的成员函数。但是由于联合既不能继承自其他类，也不能作为基类使用，所以在联合中不能含有虚函数。</p>
<p>定义联合时，首先是关键字<code>union</code>，随后是该联合的名字（可选）以及在花括号内的一组成员声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Token</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> cval;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">double</span> dval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认情况下，联合是未初始化的。可以像显式初始化聚合类一样显式初始化联合，提供的初始值会被用于初始化第一个成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Token first_token = &#123; <span class="string">&#x27;a&#x27;</span> &#125;;   <span class="comment">// initializes the cval member</span></span><br></pre></td></tr></table></figure>

<p>可以使用通用的成员访问运算符访问联合对象的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last_token.cval = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">pt-&gt;ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>匿名联合（anonymous union）是一个未命名的联合，并且在右花括号和分号之间没有任何声明。一旦定义了一个匿名联合，编译器就会自动地为该联合创建一个未命名的对象。在匿名联合的定义所在的作用域内，该联合的成员都是可以直接访问的。</p>
<p>匿名联合不能包含<code>protected</code>和<code>private</code>成员，也不能定义成员函数。</p>
<p>C++的早期版本规定，在联合中不能含有定义了构造函数或拷贝控制成员的类类型成员。C++11取消了该限制。但是如果联合的成员类型定义了自己的构造函数或拷贝控制成员，该联合的用法会比只含有内置类型成员的联合复杂得多。</p>
<ul>
<li><p>当联合只包含内置类型的成员时，可以使用普通的赋值语句改变联合的值。但是如果想将联合的值改为类类型成员对应的值，或者将类类型成员的值改为一个其他值，则必须构造或析构该类类型的成员。</p>
</li>
<li><p>当联合只包含内置类型的成员时，编译器会按照成员顺序依次合成默认构造函数或拷贝控制成员。但是如果联合含有类类型成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器会为该联合合成对应的版本并将其声明为删除的。</p>
</li>
</ul>
<p>对于联合来说，构造或销毁类类型成员的操作非常复杂。通常情况下，可以把含有类类型成员的联合内嵌在另一个类中，这个类可以管理并控制与联合的类类型成员相关的状态转换。</p>
<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>类可以定义在某个函数的内部，这种类被称为局部类。局部类定义的类型只能在定义它的作用域内可见。</p>
<p>局部类的所有成员（包括成员函数）都必须完整定义在类的内部，因此局部类的作用与嵌套类相比相差很远。</p>
<p>局部类中不允许声明静态数据成员。</p>
<p>局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员，不能使用普通局部变量。</p>
<p>常规的访问保护规则对于局部类同样适用。外层函数对局部类的私有成员没有任何访问特权。局部类可以将外层函数声明为友元。</p>
<p>可以在局部类的内部再嵌套一个类。此时嵌套类的定义可以出现在局部类之外，不过嵌套类必须定义在与局部类相同的作用域中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Nested</span>;   </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bar</span>::Nested</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。</p>
<h2 id="固有的不可移植的特性"><a href="#固有的不可移植的特性" class="headerlink" title="固有的不可移植的特性"></a>固有的不可移植的特性</h2><p>类可以将其非静态数据成员定义成位域，在一个位域中含有一定数量的二进制位。当程序需要向其他程序或硬件设备传递二进制数据时，通常会使用位域。</p>
<p>位域的声明形式是在成员名字之后紧跟一个冒号和一个常量表达式，该表达式用于指定成员所占的二进制位数。</p>
<p>位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以通常情况下使用无符号类型保存位域。位域类型的大小不能小于位域结构的总大小。</p>
<p>定义位域时建议结合<code>#pragma pack</code>指令将结构体对齐值修改为1，防止数据结构错位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存原始对齐值，设置新对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="comment">// 结构体定义……</span></span><br><span class="line"><span class="comment">// 恢复原始对齐值</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<p>位域成员按定义顺序在内存中由低地址向高地址排列，具体布局与机器相关。</p>
<p>取地址符<code>&amp;</code>不能作用于位域，因此任何指针都无法指向类的位域。</p>
<p>如果可能的话，类内部连续定义的位域会压缩在同一整数的相邻位，从而提供存储压缩。</p>
<p>访问位域的方式与访问类的其他数据成员的方式类似。操作超过1位的位域时，通常会使用内置的位运算符。</p>
<h3 id="volatile限定符"><a href="#volatile限定符" class="headerlink" title="volatile限定符"></a><code>volatile</code>限定符</h3><p>当对象的值可能在程序的控制或检测之外被改变时（如子线程），应该将该对象声明为<code>volatile</code>。关键字<code>volatile</code>的作用是告知编译器不要优化这样的对象。</p>
<p><code>volatile</code>的确切含义与机器有关，只能通过查阅编译器文档来理解。要想让一个使用了<code>volatile</code>的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行一些修改。</p>
<p><code>volatile</code>的用法和<code>const</code>类似，都是对类型的额外修饰。二者相互之间并没有影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> display_register;   </span><br><span class="line"><span class="keyword">volatile</span> Task *curr_task;        </span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> iax[max_size];    </span><br></pre></td></tr></table></figure>

<p>类可以将成员函数定义为<code>volatile</code>的。<code>volatile</code>对象只能调用<code>volatile</code>成员函数。</p>
<p><code>volatile</code>和指针的关系类似<code>const</code>。可以声明<code>volatile</code>指针、指向<code>volatile</code>对象的指针和指向<code>volatile</code>对象的<code>volatile</code>指针。</p>
<p>不能使用合成的拷贝&#x2F;移动构造函数和赋值运算符初始化<code>volatile</code>对象或者给<code>volatile</code>对象赋值。合成的成员接受的形参类型是非<code>volatile</code>常量引用，不能把非<code>volatile</code>引用绑定到<code>volatile</code>对象上。</p>
<h3 id="链接指示：extern-quot-C-quot"><a href="#链接指示：extern-quot-C-quot" class="headerlink" title="链接指示：extern &quot;C&quot;"></a>链接指示：<code>extern &quot;C&quot;</code></h3><p>C++程序有时需要调用使用其他语言编写的函数，最常见的是调用C语言函数。其他语言中的函数名字也必须在C++中进行声明。对于这些函数，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示指出任意非C++函数所用的语言。</p>
<p>链接指示有单个形式和复合形式，其不能出现在类定义或函数定义的内部。同样的链接指示必须出现在函数的每个声明处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接指示包含关键字<code>extern</code>、字符串字面值常量和一个函数声明。其中的字符串字面值常量指出了编写函数所用的语言。</p>
<p>复合形式的链接指示可以应用于整个头文件。当一个<code>#include</code>指示被放置在复合链接指示的花括号中时，头文件中的所有函数声明都会被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含自带链接指示的函数，该函数不会受到影响。</p>
<p>C++从C语言继承的标准库函数可以定义成C函数，但并非必须。选择使用C还是C++实现C标准库，是由每个C++实现决定的。</p>
<p>编写函数所使用的语言是函数类型的一部分。因此对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示，而且指向这类函数的指针也必须使用与函数本身一样的链接指示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="built_in">void</span> (*pf)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>指向C函数的指针与指向C++函数的指针是不同的类型，两者不能相互赋值或初始化（少数C++编译器支持这种赋值操作并将其视为对语言的扩展，但是从严格意义上来说它是非法的）。</p>
<p>链接指示不仅对函数本身有效，对作为返回类型或形参类型的函数指针也有效。所以如果希望给C++函数传入指向C函数的指针，必须使用类型别名。</p>
<p>通过链接指示定义函数，可以令C++函数在其他语言编写的程序中可用。编译器会为该函数生成适合于指定语言的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">double</span> dparm)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果需要在C和C++中编译同一个源文件，可以在编译C++版本时使用预处理定义<code>__cplusplus</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/15/C++%20Primer%20Chapter%2018%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/C++%20Primer%20Chapter%2018%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 18 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 21:12:55" itemprop="dateCreated datePublished" datetime="2023-06-15T21:12:55+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-24 10:41:17" itemprop="dateModified" datetime="2023-06-24T10:41:17+08:00">2023-06-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第18章-用于大型程序的工具"><a href="#第18章-用于大型程序的工具" class="headerlink" title="第18章 用于大型程序的工具"></a>第18章 用于大型程序的工具</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理机制允许程序中独立开发的部分能够在运行期间就出现的问题进行通信并做出相应的处理，使问题检测和解决过程相互分离。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>在C++中，通过抛出（throwing）一条表达式来引发（raised）一个异常。被抛出的表达式类型和当前的调用链共同决定了应该使用哪段处理代码（handler）来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配且距离最近的代码。</p>
<p>执行一个<code>throw</code>语句时，跟在<code>throw</code>后面的语句将不再执行。程序的控制权从<code>throw</code>转移到与之匹配的<code>catch</code>语句中。该<code>catch</code>可能是同一个函数中的局部<code>catch</code>，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权的转移意味着两个问题：</p>
<ul>
<li><p>沿着调用链的函数可能会提前退出。</p>
</li>
<li><p>一旦程序开始执行异常处理代码，则沿着调用链创建的对象会被销毁。</p>
</li>
</ul>
<p>抛出异常后，程序暂停执行当前函数并立即寻找对应<code>catch</code>语句的过程叫做栈展开（stack unwinding）。栈展开沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的<code>catch</code>语句为止。如果没有对应的<code>catch</code>语句，则退出主函数后查找过程结束。</p>
<ul>
<li><p>如果找到了匹配的<code>catch</code>语句，则程序进入该子句并执行其中的代码。<code>catch</code>语句执行结束后，程序会转移到与<code>try</code>块关联的最后一个<code>catch</code>语句之后的位置继续执行。</p>
</li>
<li><p>如果没有找到匹配的<code>catch</code>语句，程序会调用标准库的<code>terminate</code>函数，终止运行。</p>
</li>
</ul>
<p>在栈展开过程中，位于调用链上的语句块可能会提前退出，其中的局部对象也会被销毁。如果异常发生在构造函数或者数组及容器的元素初始化过程中，则当前的对象可能只构造了一部分，此时必须确保已构造的成员能被正确销毁。</p>
<p>如果一个块分配了资源，并且在执行资源释放代码前发生了异常，则资源不会被释放。</p>
<p>由于栈展开可能会调用析构函数，因此析构函数不应该抛出不能被它自身处理的异常。</p>
<p>编译器使用异常抛出表达式对异常对象（exception object）进行拷贝初始化，因此<code>throw</code>语句中的表达式必须具有完全类型。</p>
<p>抛出一条表达式时，该表达式的静态编译类型决定了异常对象的类型。如果<code>throw</code>表达式解引用一个基类指针，而该指针实际指向派生类对象，则只有基类部分会被抛出。</p>
<p>抛出指针时必须确保在任何对应的处理代码中，指针指向的对象一定存在。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p><code>catch</code>语句（catch clause）中的异常声明（exception declaration）类似只包含一个形参的函数形参列表。声明的类型决定了处理代码所能捕获的异常类型。该类型必须是完全类型，可以是左值引用，但不能是右值引用。如果<code>catch</code>无须访问抛出的表达式，则可以忽略捕获形参的名字。</p>
<p>进入<code>catch</code>语句后，使用异常对象初始化异常声明中的参数。<code>catch</code>参数的特性和函数参数类似。</p>
<ul>
<li><p>如果<code>catch</code>的参数类型是非引用类型，则该参数是异常对象的一个副本，改变参数不会影响异常对象本身。</p>
</li>
<li><p>如果<code>catch</code>的参数类型是引用类型，则该参数是异常对象的一个别名，改变参数就是改变异常对象本身。</p>
</li>
<li><p>在继承体系中，如果<code>catch</code>的参数类型是基类类型，则可以使用其派生类类型的异常对象对其初始化。</p>
<ul>
<li><p><code>catch</code>的参数是基类非引用类型时，异常对象会被切除一部分。</p>
</li>
<li><p><code>catch</code>的参数是基类引用类型时，以常规方式绑定到异常对象。</p>
</li>
</ul>
</li>
</ul>
<p>异常声明的静态类型决定了<code>catch</code>语句所能执行的操作。如果<code>catch</code>的参数是基类类型，则无法使用派生类特有的成员。</p>
<p>通常情况下，如果<code>catch</code>接受的异常与某个继承体系有关，则最好将<code>catch</code>参数定义为引用类型。</p>
<p>查找异常处理代码时，最终结果是第一个与异常匹配的<code>catch</code>语句，但这未必是最佳匹配。因此，越特殊的<code>catch</code>越应该位于整个<code>catch</code>列表的前端。当程序使用具有继承关系的异常时，派生类异常的处理代码应该位于基类异常的处理代码之前。</p>
<p>异常和异常声明的匹配规则比函数参数严格，绝大多数类型转换都不能使用。</p>
<ul>
<li><p>允许从非常量到常量的类型转换。</p>
</li>
<li><p>允许从派生类到基类的类型转换。</p>
</li>
<li><p>数组被转换成指向数组元素类型的指针，函数被转换成指向该函数类型的指针。</p>
</li>
</ul>
<p>有时一个单独的<code>catch</code>语句不能完整处理某个异常。执行完一些校正操作后，当前的<code>catch</code>可能会让位于调用链上层的函数继续处理异常。一个<code>catch</code>语句通过重新抛出（rethrowing）的操作将异常传递给另一个<code>catch</code>语句。重新抛出是一条不包含表达式的<code>throw</code>语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>;</span><br></pre></td></tr></table></figure>

<p>空<code>throw</code>语句只能出现在<code>catch</code>或<code>catch</code>语句调用的函数之内。如果在异常处理代码之外的区域遇到了空<code>throw</code>语句，编译器将调用<code>terminate</code>函数。</p>
<p>重新抛出语句不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。如果<code>catch</code>语句修改了其参数并重新抛出异常，则只有当<code>catch</code>异常声明是引用类型时，程序对参数所做的改变才会被保留并继续传播。</p>
<p>使用省略号<code>...</code>作为异常声明可以一次性捕获所有异常，这种处理代码被称为捕获所有异常（catch-all）的处理代码，可以与任意类型的异常相匹配。</p>
<p><code>catch(…)</code>通常与重新抛出语句一起使用。</p>
<p>如果<code>catch(…)</code>与其他<code>catch</code>语句一起使用，则<code>catch(…)</code>必须位于最后，否则<code>catch(…)</code>后面的<code>catch</code>语句永远不会被匹配。</p>
<h3 id="函数try语句块与构造函数"><a href="#函数try语句块与构造函数" class="headerlink" title="函数try语句块与构造函数"></a>函数<code>try</code>语句块与构造函数</h3><p>要想处理构造函数初始值列表抛出的异常，必须将构造函数写成函数<code>try</code>语句块（function try block）的形式。函数<code>try</code>语句块使得一组<code>catch</code>语句可以同时处理构造函数体和构造函数初始化过程中的异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) <span class="keyword">try</span> :</span><br><span class="line">    <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> std::bad_alloc &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">handle_out_of_memory</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>try</code>语句块的<code>catch</code>语句会在结尾处隐式地重新抛出异常，通知上层函数对象构造失败。上层函数需要继续处理该异常。</p>
<p>在初始化构造函数参数时发生的异常不属于函数<code>try</code>语句块处理的范围。</p>
<h3 id="noexcept异常说明"><a href="#noexcept异常说明" class="headerlink" title="noexcept异常说明"></a><code>noexcept</code>异常说明</h3><p>在C++11中，可以通过提供<code>noexcept</code>说明（noexcept specification）来指出某个函数不会抛出异常。</p>
<p><code>noexcept</code>说明的出现位置：</p>
<ul>
<li><p>关键字<code>noexcept</code>位于函数的参数列表之后，尾置返回类型之前。</p>
</li>
<li><p>对于一个函数来说，<code>noexcept</code>说明必须同时出现在该函数的所有声明和定义语句中。</p>
</li>
<li><p>函数指针的声明和定义也可以指定<code>noexcept</code>。</p>
</li>
<li><p>在<code>typedef</code>或类型别名中不能使用<code>noexcept</code>。</p>
</li>
<li><p>在成员函数中，关键字<code>noexcept</code>位于<code>const</code>或引用限定符之后，<code>final</code>、<code>override</code>或虚函数的<code>=0</code>之前。</p>
</li>
</ul>
<p>编译器并不会在编译时检查<code>noexcept</code>说明。如果一个函数在指定了<code>noexcept</code>的同时又含有<code>throw</code>语句或其他可能抛出异常的操作，仍然会通过编译（个别编译器可能会提出警告）。</p>
<p>一旦<code>noexcept</code>函数抛出异常，程序会调用<code>terminate</code>函数终止运行（该过程是否执行栈展开未作规定）。因此<code>noexcept</code>可以用于两种情况：</p>
<ul>
<li><p>确认函数不会抛出异常。</p>
</li>
<li><p>不知道该如何处理函数抛出的异常。</p>
</li>
</ul>
<p>指明某个函数不会抛出异常可以让调用者不必再考虑异常处理操作。</p>
<p>早期的C++版本设计了一套更详细的异常说明方案。函数可以使用一个关键字<code>throw</code>，后面跟上用括号包围的异常类型列表，用于指定函数可能抛出的异常类型。关键字<code>throw</code>出现的位置与C++11的<code>noexcept</code>相同。该方案在C++11中被取消。但如果一个函数被声明为<code>throw()</code>的，则也说明该函数不会抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">noexcept</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">(<span class="type">int</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;  </span><br></pre></td></tr></table></figure>

<p><code>noexcept</code>说明符接受一个可选的实参，该实参必须能转换为<code>bool</code>类型。如果实参为<code>true</code>，则函数不会抛出异常；如果实参为<code>false</code>，则函数可能抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">(<span class="type">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">(<span class="type">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;    </span><br></pre></td></tr></table></figure>

<p><code>noexcept</code>运算符（noexcept operator）是一个一元运算符，返回<code>bool</code>类型的右值常量表达式，表示给定的运算对象是否会抛出异常。和<code>sizeof</code>类似，<code>noexcept</code>运算符也不会对运算对象求值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">noexcept</span>(e)</span><br></pre></td></tr></table></figure>

<p>当<code>e</code>调用的函数都含有<code>noexcept</code>说明且<code>e</code>本身不含有<code>throw</code>语句时，上述表达式返回<code>true</code>，否则返回<code>false</code>。</p>
<p><code>noexcept</code>运算符通常在<code>noexcept</code>说明符的实参中使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span></span>;   </span><br></pre></td></tr></table></figure>

<p>函数指针与该指针指向的函数必须具有一致的异常说明。如果某个函数指针是<code>noexcept</code>的，则该指针只能指向<code>noexcept</code>函数；如果显式或隐式地说明了函数指针可能抛出异常，则该指针可以指向任何函数。</p>
<p>如果一个虚函数是<code>noexcept</code>的，则后续派生出来的虚函数必须也是<code>noexcept</code>的。如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许，也可以禁止抛出异常。</p>
<p>编译器合成拷贝控制成员时，也会生成一个异常声明。如果所有的成员和基类操作都含有<code>noexcept</code>说明，则合成成员也是<code>noexcept</code>的。</p>
<h3 id="异常类层次"><a href="#异常类层次" class="headerlink" title="异常类层次"></a>异常类层次</h3><p><code>exception</code>类型只定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为<code>what</code>的虚成员。<code>what</code>函数返回一个<code>const char*</code>，指向一个以<code>NULL</code>结尾的字符数组，并且不会抛出异常。</p>
<p><code>exception</code>、<code>bad_cast</code>和<code>bad_alloc</code>类型定义了默认构造函数。<code>runtime_error</code>和<code>logic_error</code>类型没有默认构造函数，但是有一个接受C风格字符串或<code>string</code>类型实参的构造函数，该实参通常用于提供错误信息。<code>what</code>函数返回用于初始化异常对象的错误信息。</p>
<p>实际编程中通常会自定义<code>exception</code>（或者<code>exception</code>的标准库派生类）的派生类以扩展其继承体系。这些面向具体应用的异常类表示了与应用相关的异常状态。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>大型应用程序通常会使用多个独立开发的库，其中某些名字可能会相互冲突。多个库将名字放置在全局命名空间中会产生命名空间污染（namespace pollution）。</p>
<p>命名空间分割了全局命名空间，其中每个命名空间都是一个作用域。</p>
<h3 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h3><p>命名空间的定义包含两部分：关键字<code>namespace</code>和随后的命名空间名字。在命名空间名字后面是一系列由花括号包围的声明和定义。能出现在全局作用域中的声明就也能出现在命名空间中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123; / * ... * /&#125;;</span><br><span class="line">    Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;);</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Query</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Query_base</span> &#123; <span class="comment">/* ... */</span>&#125;;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>命名空间作用域后面不需要分号结束。</p>
<p>和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。</p>
<p>每个命名空间都是一个作用域，不同命名空间内可以有相同名字的成员。</p>
<p>定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所使用的名字属于哪个命名空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cplusplus_primer::Query q = cplusplus_primer::<span class="built_in">Query</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>命名空间的定义可以是不连续的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// declarations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果之前没有名为<code>nsp</code>的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间定义并为其添加新的成员声明。</p>
<p>利用命名空间不连续的特性可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似管理自定义类和函数的方式。</p>
<ul>
<li><p>命名空间的一部分成员用于定义类，以及声明作为类接口的函数和对象。这些成员应该放置在头文件中。</p>
</li>
<li><p>命名空间成员的定义部分放置在另外的源文件中。源文件需要包含对应的头文件。</p>
</li>
</ul>
<p>程序中的某些实体只能定义一次，如非内联函数、静态数据成员等，命名空间中定义的名字也需要满足该要求。</p>
<p>通常情况下，<code>#include</code>不应该出现在命名空间内部。否则头文件中的所有名字都会被定义为该命名空间的成员。</p>
<p>定义多个类型不相关的命名空间时应该使用单独的文件分别表示每个类型。</p>
<p>可以在命名空间的外部定义该命名空间的成员。命名空间对于名字的声明必须在作用域内，同时该名字的定义需要明确指出其所属的命名空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cplusplus_primer::Sales_data</span><br><span class="line">cplusplus_primer::<span class="keyword">operator</span>+(<span class="type">const</span> Sales_data&amp; lhs, <span class="type">const</span> Sales_data&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Sales_data <span class="title">ret</span><span class="params">(lhs)</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板特例化必须定义在原始模板所属的命名空间中。可以在命名空间内部添加模板特例化声明，而在外部对其进行定义。</p>
<p>全局作用域中定义的名字被隐式添加到全局命名空间（global namespace）中。全局命名空间以隐式方式声明，在所有程序中都存在。</p>
<p>作用域运算符<code>::</code>可以用于全局命名空间的成员。因为全局命名空间是隐式声明的，所以它并没有名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::member_name</span><br></pre></td></tr></table></figure>

<p>命名空间可以嵌套。嵌套的命名空间同时也是一个嵌套的作用域，它嵌套在外层命名空间的作用域内。内层命名空间声明的名字会隐藏外层命名空间的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码在访问时需要在名字前添加限定符。</p>
<p>C++11新增了内联命名空间（inline namespace）。和一般的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。定义内联命名空间的方式是在<code>namespace</code>前添加关键字<code>inline</code>。<code>inline</code>必须出现在该命名空间第一次定义的地方。</p>
<p>当应用程序的代码在两次发布之间发生了改变时，通常会使用内联命名空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FourthEd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Item_base</span> &#123; <span class="comment">/* ... */</span>&#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Query_base</span> &#123; <span class="comment">/* ... */</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cplusplus_primer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FifthEd.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FourthEd.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>FifthEd</code>是内联的，所以形如<code>cplusplus_primer::</code>的代码可以直接获得<code>FifthEd</code>的成员。如果想使用早期版本，则必须加上完整的外层命名空间名字。</p>
<p>未命名的命名空间（unnamed namespace）指关键字<code>namespace</code>后紧跟以花括号包围的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，直到程序结束才销毁。</p>
<p>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字在每个包含该头文件的文件中对应不同实体。</p>
<p>定义在未命名的命名空间中的名字可以直接使用，不能对其使用作用域运算符。</p>
<p>定义在未命名的命名空间中的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在最外层作用域中，则该命名空间中的名字必须要与全局作用域中的名字有所区别。</p>
<p>在标准C++引入命名空间的概念之前，程序需要将名字声明为<code>static</code>的以令其对整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为<code>static</code>的全局实体在其所在的文件之外不可见。该做法已经被C++标准取消，现在应该使用未命名的命名空间。</p>
<h3 id="使用命名空间成员"><a href="#使用命名空间成员" class="headerlink" title="使用命名空间成员"></a>使用命名空间成员</h3><p>可以使用关键字<code>namespace</code>和<code>=</code>为命名空间定义别名（namespace alias）。别名必须出现在命名空间的定义之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</span><br></pre></td></tr></table></figure>

<p>一个命名空间可以有多个别名，它们都与命名空间的原名等价。</p>
<p>一条<code>using</code>声明（using declaration）一次只引入命名空间的一个成员。</p>
<p><code>using</code>声明的有效范围从<code>using</code>声明语句开始，一直到<code>using</code>声明所在的作用域结束为止。在此过程中，外层作用域的同名实体会被隐藏。未加限定的名字只能在<code>using</code>声明所在的作用域及其内层作用域中使用。</p>
<p><code>using</code>声明可以出现在全局作用域、局部作用域、命名空间作用域和类的作用域中。在类的作用域中使用时，<code>using</code>声明只能指向基类成员。</p>
<p>和<code>using</code>声明不同，<code>using</code>指示使某个命名空间中的所有名字都可见。</p>
<p><code>using</code>指示可以出现在全局作用域、局部作用域和命名空间作用域中，不能出现在类的作用域中。</p>
<p>如果对<code>std</code>等命名空间使用了<code>using</code>指示而未做任何特殊控制的话，会重新引入多个库之间的名字冲突问题。</p>
<p> <code>using</code>指示具有将命名空间成员提升到包含命名空间本身和<code>using</code>指示的最近外层作用域的能力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A; </span><br><span class="line">    cout &lt;&lt; i * j &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当命名空间被注入到其外层作用域之后，该命名空间中定义的名字可能会与其外层作用域的成员冲突。这种冲突允许存在，但是要想使用冲突的名字，就必须明确指出名字的版本。</p>
<p>头文件如果在其顶层作用域中使用<code>using</code>声明或<code>using</code>指示，则会将名字注入到包含该头文件的所有文件中。通常，头文件只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用<code>using</code>声明或<code>using</code>指示。</p>
<p>相比于使用<code>using</code>指示，在程序中对命名空间中的每个成员分别使用<code>using</code>声明效果更好。</p>
<ul>
<li><p>如果程序使用了多个不同的库，而这些库中的名字通过<code>using</code>指示变得可见，则全局命名空间污染问题将重新出现。</p>
</li>
<li><p><code>using</code>指示引发的二义性错误只有在使用了冲突名字的地方才会被发现。而<code>using</code>声明引发的二义性错误在声明处就能发现。</p>
</li>
</ul>
<p>建议在命名空间本身的实现文件中使用<code>using</code>指示。</p>
<h3 id="类、命名空间与作用域"><a href="#类、命名空间与作用域" class="headerlink" title="类、命名空间与作用域"></a>类、命名空间与作用域</h3><p>对命名空间内部名字的查找遵循常规查找规则：由内向外依次查找每个外层作用域。只有位于开放的块中且在使用点之前声明的名字才会被考虑。</p>
<p>对于位于命名空间中的类来说，名字的常规查找规则依然适用：当成员函数使用某个名字时，首先在该成员中查找，然后在类（包括基类）中查找，接着在外层作用域中查找。</p>
<p>可以从函数的限定名推断出名字查找时检查作用域的顺序，限定名以相反的顺序指出被查找的作用域。</p>
<p>命名空间中名字的隐藏规则有一个例外：传递给函数一个类类型的对象、指向类的引用或指针时，除了在常规作用域查找名字外，还会查找实参类所属的命名空间。该例外允许概念上作为类接口一部分的非成员函数无须单独的<code>using</code>声明就能被程序使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::string s;</span><br><span class="line">std::cin &gt;&gt; s;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">std::<span class="keyword">operator</span>&gt;&gt;(std::cin, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若该规则不存在，则必须为&gt;&gt;运算符提供using声明</span></span><br><span class="line"><span class="keyword">using</span> std::<span class="keyword">operator</span>&gt;&gt;;</span><br><span class="line"><span class="comment">// 或者显式使用std::operator&gt;&gt;</span></span><br><span class="line">std::<span class="keyword">operator</span>&gt;&gt;(std::cin, s);</span><br></pre></td></tr></table></figure>

<p>标准库定义的<code>move</code>和<code>forward</code>模板函数接受一个右值引用形参，可以匹配任何类型。如果应用程序也定义了一个接受单一参数的<code>move</code>和<code>forward</code>函数，则不管形参是什么类型，都会与标准库的版本冲突。对于这两个函数来说，冲突大多是无意的，因此建议使用它们的含有限定语的完整版本（即<code>std::move</code>、<code>std::forward</code>）。</p>
<p>如果一个未声明的类或函数第一次出现在友元声明中，则会被认定是离它最近的外层命名空间的成员。</p>
<h3 id="重载与命名空间"><a href="#重载与命名空间" class="headerlink" title="重载与命名空间"></a>重载与命名空间</h3><p><code>using</code>声明和<code>using</code>指示能将某些函数添加到候选函数集。</p>
<p>确定候选函数集时，会在函数的每个实参类（以及实参类的基类）所属的命名空间中搜索候选函数。这些命名空间中所有与被调用函数同名的函数都会被添加到候选集当中，即使其中某些函数在调用语句处不可见也是如此。</p>
<p><code>using</code>声明语句声明的是一个名字，而非一个特定的函数。一个<code>using</code>声明囊括了重载函数的所有版本以确保不违反命名空间的接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">using</span> <span class="title">NS::print</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">// error</span></span><br><span class="line"><span class="keyword">using</span> NS::print;        <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>一个<code>using</code>声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果<code>using</code>声明出现在局部作用域中，则引入的名字会隐藏外层作用域的相关声明。如果<code>using</code>声明所在的作用域中已经有一个函数与引入的函数同名且形参列表相同，则该<code>using</code>声明会引发错误。除此之外，<code>using</code>声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。</p>
<p><code>using</code>指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域中的函数同名，则命名空间的函数会被添加到重载集合中。</p>
<p>与<code>using</code>声明不同，<code>using</code>指示引入一个与已有函数形参列表完全相同的函数并不会引发错误。但需要明确指出调用的是命名空间中的函数版本还是当前作用域中的版本。</p>
<p>如果存在多个<code>using</code>指示，则来自每个命名空间的名字都会成为候选函数集的一部分。</p>
<h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p>多重继承（Multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>派生类的派生列表中可以包含多个基类。每个基类都包含一个可选的访问说明符。和单继承相同，如果访问说明符被省略，则关键字<code>class</code>对应的默认访问说明符是<code>private</code>，关键字<code>struct</code>对应的是<code>public</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span> : <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>和单继承相同，多重继承的派生列表也只能包含已经被定义过的类，且这些类不能是<code>final</code>的。</p>
<p>多重继承关系中，派生类对象包含每个基类的子对象。</p>
<p>构造一个多重继承的派生类对象将同时构造并初始化它的所有基类子对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Panda::<span class="built_in">Panda</span>(std::string name, <span class="type">bool</span> onExhibit)</span><br><span class="line">    : <span class="built_in">Bear</span>(name, onExhibit, <span class="string">&quot;Panda&quot;</span>),</span><br><span class="line">      <span class="built_in">Endangered</span>(Endangered::critical) &#123; &#125;</span><br><span class="line">Panda::<span class="built_in">Panda</span>()</span><br><span class="line">    : <span class="built_in">Endangered</span>(Endangered::critical) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类的出现顺序一致，与构造函数初始值列表中基类的顺序无关。</p>
<p>C++11允许派生类从它的一个或多个基类中继承构造函数，但如果从多个基类中继承了相同的构造函数（即形参列表完全相同），程序会产生错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Base1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Base1</span>(<span class="type">const</span> std::string&amp;);</span><br><span class="line">    <span class="built_in">Base1</span>(std::shared_ptr&lt;<span class="type">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Base2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="type">const</span> std::string&amp;);</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;   </span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果一个类从它的多个基类中继承了相同的构造函数，则必须为该构造函数定义其自己的版本。</p>
<p>和单继承相同，多重继承的派生类如果定义了自己的拷贝&#x2F;赋值构造函数和赋值运算符，则必须在完整的对象上执行这些操作。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动处理其基类部分。在合成版本的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作。</p>
<h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>多重继承和单继承相同，某个可访问基类的指针或引用可以直接指向派生类对象。</p>
<p>编译器不会在派生类向基类的几种转换中进行比较和选择。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Bear&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Endangered&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Panda <span class="title">ying_yang</span><span class="params">(<span class="string">&quot;ying_yang&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>和单继承相同，对象、指针和引用的静态类型决定了我们可以使用的成员。</p>
<h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>在单继承中，派生类的作用域嵌套在直接基类和间接基类的作用域中。名称查找沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字会隐藏基类的同名成员。在多重继承中，相同的查找过程在所有基类中同时进行。如果名字在多个基类中都被找到，则会产生二义性错误。</p>
<p>派生类可以从多个基类中分别继承名字相同的成员，但是在使用该名字时必须明确指出其版本。避免潜在二义性的最好方法是在派生类中定义新的版本。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再次间接继承该类。</p>
<p>默认情况下，派生类含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中会包含该类的多个子对象。这种默认情况对某些类并不适用。例如<code>iostream</code>，它直接继承自<code>istream</code>和<code>ostream</code>，而<code>istream</code>和<code>ostream</code>都继承自<code>base_ios</code>，所以<code>iostream</code>继承了<code>base_ios</code>两次。如果<code>iostream</code>对象包含<code>base_ios</code>的两份拷贝，则无法在同一个缓冲区中进行读写操作。</p>
<p>虚继承可以让某个类共享它的基类，其中共享的基类子对象称为虚基类（virtual base class）。在该机制下，不论虚基类在继承体系中出现了多少次，派生类都只包含唯一一个共享的虚基类子对象。</p>
<p>通常情况下，使用虚继承的类层次是由一个人或一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个是虚基类，况且新基类的开发者也无法改变已存在的类体系。</p>
<p>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</p>
<p>指定虚基类的方式是在派生列表中添加关键字<code>virtual</code>。</p>
<p>不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。</p>
<p>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，而且不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则也可以直接访问该成员。但如果成员被多个基类覆盖，则一般情况下派生类必须为该成员定义新的版本。例如，假设类<code>B</code>定义了一个名为<code>X</code>的成员，<code>D1</code>和<code>D2</code>都从<code>B</code>虚继承得到，<code>D</code>继承了<code>D1</code>和<code>D2</code>。则在<code>D</code>的作用域中，<code>X</code>通过<code>D</code>的两个基类都是可见的。如果通过<code>D</code>的对象使用<code>X</code>，则有三种可能性：</p>
<ul>
<li><p>如果<code>D1</code>和<code>D2</code>中都没有<code>X</code>的定义，则<code>X</code>会被解析为<code>B</code>的成员，此时不存在二义性。</p>
</li>
<li><p>如果<code>D1</code>和<code>D2</code>中的某一个定义了<code>X</code>，派生类的<code>X</code>会比共享虚基类<code>B</code>的<code>X</code>优先级更高，此时同样没有二义性。</p>
</li>
<li><p>如果<code>D1</code>和<code>D2</code>都定义了<code>X</code>，则直接访问<code>X</code>会产生二义性问题。</p>
</li>
</ul>
<h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p>在虚派生中，虚基类是由最低层的派生类初始化的。如果按普通规则处理，虚基类将会在多条继承路径上被重复初始化。</p>
<p>继承体系中的每个类都可能在某个时刻成为“最低层的派生类”。只要能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。即使虚基类不是派生类的直接基类，构造函数也可以进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Bear::<span class="built_in">Bear</span>(std::string name, <span class="type">bool</span> onExhibit)</span><br><span class="line">    : <span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Bear&quot;</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">Raccoon::<span class="built_in">Raccoon</span>(std::string name, <span class="type">bool</span> onExhibit)</span><br><span class="line">    : <span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Raccoon&quot;</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">Panda::<span class="built_in">Panda</span>(std::string name, <span class="type">bool</span> onExhibit)</span><br><span class="line">    : <span class="built_in">ZooAnimal</span>(name, onExhibit, <span class="string">&quot;Panda&quot;</span>),</span><br><span class="line">      <span class="built_in">Bear</span>(name, onExhibit),</span><br><span class="line">      <span class="built_in">Raccoon</span>(name, onExhibit),</span><br><span class="line">      <span class="built_in">Endangered</span>(Endangered::critical),</span><br><span class="line">      <span class="function">sleeping <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>构造含有虚基类的对象时，首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，之后再按照直接基类在派生列表中出现的顺序依次对其初始化。</p>
<p>一个类可以有多个虚基类，此时这些虚子对象按照它们在派生列表中出现的顺序依次构造。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/14/C++%20Primer%20Chapter%2017%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/14/C++%20Primer%20Chapter%2017%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 17 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-14 14:24:57" itemprop="dateCreated datePublished" datetime="2023-06-14T14:24:57+08:00">2023-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-24 10:25:26" itemprop="dateModified" datetime="2023-06-24T10:25:26+08:00">2023-06-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第17章-标准库特殊设施"><a href="#第17章-标准库特殊设施" class="headerlink" title="第17章 标准库特殊设施"></a>第17章 标准库特殊设施</h1><h2 id="tuple类"><a href="#tuple类" class="headerlink" title="tuple类"></a><code>tuple</code>类</h2><p><code>tuple</code>是类似<code>pair</code>的模板，定义在头文件<code>tuple</code>中。与<code>pair</code>不同，<code>tuple</code>可以有任意数量的成员。如果希望将一些数据组合成单一对象，但又不想定义新数据结构时，可以使用<code>tuple</code>。</p>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化<code>tuple</code></h3><p>定义<code>tuple</code>时需要指定每个成员的类型。创建<code>tuple</code>对象时，可以使用<code>tuple</code>的默认构造函数，它会对每个成员进行值初始化。或者给每个成员提供初始值。包含初始值的构造函数是<code>explicit</code>的，因此必须使用直接初始化语法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">size_t</span>, <span class="type">size_t</span>, <span class="type">size_t</span>&gt; threeD = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;   <span class="comment">// error</span></span><br><span class="line">tuple&lt;<span class="type">size_t</span>, <span class="type">size_t</span>, <span class="type">size_t</span>&gt; threeD&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;      <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>类似<code>make_pair</code>，<code>make_tuple</code>函数可以生成<code>tuple</code>对象。<code>tuple</code>的类型由初始值决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = <span class="built_in">make_tuple</span>(<span class="string">&quot;0-999-78345-X&quot;</span>, <span class="number">3</span>, <span class="number">20.00</span>);</span><br></pre></td></tr></table></figure>

<p>可以使用<code>get</code>访问<code>tuple</code>的成员。<code>get</code>是一个函数模板，使用时必须指定一个显式模板实参，表示要访问的成员索引。传递给<code>get</code>一个<code>tuple</code>实参后，会返回其指定成员的引用。</p>
<p>可以使用<code>tuple_size</code>和<code>tuple_element</code>这两个辅助类模板查询<code>tuple</code>成员的数量和类型。</p>
<ul>
<li><p><code>tuple_size</code>通过一个<code>tuple</code>类型来初始化，它有一个名为<code>value</code>的静态公有数据成员，类型为<code>size_t</code>，表示给定<code>tuple</code>中成员的数量。</p>
</li>
<li><p><code>tuple_element</code>通过一个索引值（整型常量）和一个<code>tuple</code>类型来初始化，它有一个名为<code>type</code>的公有数据成员，表示给定<code>tuple</code>中指定成员的类型。</p>
</li>
</ul>
<p>使用<code>decltype</code>可以确定一个对象的类型。</p>
<p><code>tuple</code>的关系和相等运算符逐对比较两个<code>tuple</code>对象的成员。只有当两个<code>tuple</code>的成员数量相等时才可以进行比较。使用<code>tuple</code>的相等或不等运算符时，每对成员必须支持<code>==</code>运算符；使用<code>tuple</code>的关系运算符时，每对成员必须支持<code>&lt;</code>运算符。</p>
<p>由于<code>tuple</code>定义了<code>&lt;</code>和<code>==</code>运算符，因此<code>tuple</code>序列可以被传递给算法，无序容器的关键字也可以使用<code>tuple</code>类型。</p>
<h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用<code>tuple</code>返回多个值</h3><p><code>tuple</code>的一个常见用途是从一个函数返回多个值。</p>
<h2 id="bitset类型"><a href="#bitset类型" class="headerlink" title="bitset类型"></a><code>bitset</code>类型</h2><p>标准库在头文件<code>bitset</code>中定义了<code>bitset</code>类，用于处理二进制位。<code>bitset</code>可以处理超过最长整型类型大小的位集合。</p>
<h3 id="定义和初始化bitset"><a href="#定义和初始化bitset" class="headerlink" title="定义和初始化bitset"></a>定义和初始化<code>bitset</code></h3><p><code>bitset</code>类是一个模板，类似<code>array</code>，具有固定的大小。定义一个<code>bitset</code>时需要指明它包含的二进制位数。</p>
<p>使用一个整型值初始化<code>bitset</code>时，此值会被转换为<code>unsigned long long</code>类型并被当作位模式处理。<code>bitset</code>中的二进制位就是此模式的副本。如果<code>bitset</code>的大小大于<code>unsigned long long</code>中的二进制位数，剩余的高位会被置为0。如果<code>bitset</code>的大小小于<code>unsigned long long</code>中的二进制位数，则只使用给定值的低位部分。</p>
<p>可以使用<code>string</code>或字符数组指针来初始化<code>bitset</code>，字符直接表示位模式。使用字符串表示数时，字符串中下标最小的字符对应<code>bitset</code>的高位。如果<code>string</code>包含的字符数比<code>bitset</code>少，则<code>bitset</code>的高位被置为0。</p>
<h3 id="bitset操作"><a href="#bitset操作" class="headerlink" title="bitset操作"></a><code>bitset</code>操作</h3><p><code>bitset</code>的下标运算符对<code>const</code>属性进行了重载。<code>const</code>版本的下标运算符在指定位置置位时返回<code>true</code>，否则返回<code>false</code>。非<code>const</code>版本返回<code>bitset</code>定义的一个特殊类型，用来控制指定位置的值。</p>
<p><code>to_ulong</code>和<code>to_ullong</code>操作用来提取<code>bitset</code>的值。只有当<code>bitset</code>的大小不大于对应操作的返回值（<code>to_ulong</code>为<code>unsigned long</code>，<code>to_ullong</code>为<code>unsigned long long</code>）时，才能使用这两个操作。如果<code>bitset</code>中的值不能存入给定类型，则会引发<code>overflow_error</code>异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulong = bitvec3.<span class="built_in">to_ulong</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ulong = &quot;</span> &lt;&lt; ulong &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><code>bitset</code>的输入运算符从输入流读取字符，保存到临时的<code>string</code>对象中。遇到下列情况时停止读取：</p>
<ul>
<li><p>读取的字符数达到对应<code>bitset</code>的大小。</p>
</li>
<li><p>遇到不是1和0的字符。</p>
</li>
<li><p>遇到文件结尾。</p>
</li>
<li><p>输入出现错误。</p>
</li>
</ul>
<p>读取结束后用临时<code>string</code>对象初始化<code>bitset</code>。如果读取的字符数小于<code>bitset</code>的大小，则<code>bitset</code>的高位被置为0。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种描述字符序列的方法。C++11新标准增加了正则表达式库，定义在头文件<code>regex</code>中，包含多个组件。</p>
<p><code>regex</code>类表示一个正则表达式。</p>
<p><code>regex_match</code>和<code>regex_search</code>函数确定一个给定的字符序列与一个<code>regex</code>是否匹配。如果整个输入序列与表达式匹配，则<code>regex_match</code>函数返回<code>true</code>；如果输入序列中的一个子串与表达式匹配，则<code>regex_search</code>函数返回<code>true</code>。这两个函数的其中一个重载版本接受一个类型为<code>smatch</code>的附加参数。如果匹配成功，函数会将匹配信息保存在给定的<code>smatch</code>对象中。</p>
<h3 id="使用正则表达式库"><a href="#使用正则表达式库" class="headerlink" title="使用正则表达式库"></a>使用正则表达式库</h3><p>默认情况下，<code>regex</code>使用的正则表达式语言是ECMAScript。</p>
<p>定义一个<code>regex</code>或者对一个<code>regex</code>调用<code>assign</code>为其赋新值时，可以指定一些标志来影响<code>regex</code>的操作。<code>ECMAScript</code>、<code>basic</code>、<code>extended</code>、<code>awk</code>、<code>grep</code>和<code>egrep</code>这六个标志指定编写正则表达式时所使用的语言。这六个标志中必须设置其中之一，且只能设置一个。</p>
<p>正则表达式的语法是否正确是在运行期间解析的。如果正则表达式存在错误，标准库会抛出类型为<code>regex_error</code>的异常。除了<code>what</code>操作外，<code>regex_error</code>还有一个名为<code>code</code>的成员，用来返回错误类型对应的数值编码。<code>code</code>返回的值是由具体实现定义的。RE库能抛出的标准错误如下，<code>code</code>返回对应错误的编号（从0开始）。</p>
<p>正则表达式在程序运行时才编译，这是一个非常慢的操作。因此构造一个<code>regex</code>对象或者给一个已经存在的<code>regex</code>赋值是很耗时间的。为了最小化这种开销，应该尽量避免创建不必要的<code>regex</code>。特别是在循环中使用正则表达式时，应该在循环体外部创建<code>regex</code>对象。</p>
<p>RE库为不同的输入序列都定义了对应的类型。使用时RE库类型必须与输入类型匹配。</p>
<ul>
<li><p><code>regex</code>类保存<code>char</code>类型的正则表达式；<code>wregex</code>保存<code>wchar_t</code>类型的正则表达式。</p>
</li>
<li><p><code>smatch</code>表示<code>string</code>类型的输入序列；<code>cmatch</code>表示字符数组类型的输入序列；<code>wsmatch</code>表示<code>wstring</code>类型的输入序列；<code>wcmatch</code>表示宽字符数组类型的输入序列。</p>
</li>
</ul>
<h3 id="匹配与regex迭代器类型"><a href="#匹配与regex迭代器类型" class="headerlink" title="匹配与regex迭代器类型"></a>匹配与<code>regex</code>迭代器类型</h3><p><code>regex</code>迭代器是一种迭代器适配器，它被绑定到一个输入序列和一个<code>regex</code>对象上，每种输入类型都有对应的迭代器类型。</p>
<p><code>sregex_iterator</code>操作：</p>
<p>以<code>sregex_iterator</code>为例，将<code>sregex_iterator</code>绑定到一个<code>string</code>和一个<code>regex</code>对象时，迭代器自动定位至给定<code>string</code>中的第一个匹配位置。即，<code>sregex_iterator</code>构造函数对给定<code>string</code>和<code>regex</code>调用<code>regex_search</code>。解引用迭代器时，返回最近一次搜索结果的<code>smatch</code>对象。递增迭代器时，它调用<code>regex_search</code>在输入<code>string</code>中查找下一个匹配位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">pattern</span><span class="params">(<span class="string">&quot;[^c]ei&quot;</span>)</span></span>;</span><br><span class="line">pattern = <span class="string">&quot;[[:alpha:]]*&quot;</span> + pattern + <span class="string">&quot;[[:alpha:]]*&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern, regex::icase)</span></span>;     </span><br><span class="line"><span class="keyword">for</span> (sregex_iterator <span class="built_in">it</span>(file.<span class="built_in">begin</span>(), file.<span class="built_in">end</span>(), r), end_it;</span><br><span class="line">        it != end_it; ++it)</span><br><span class="line">    cout &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;   <span class="comment">// matched word</span></span><br></pre></td></tr></table></figure>

<p>匹配类型有两个名为<code>prefix</code>和<code>suffix</code>的成员，分别返回表示输入序列中当前匹配之前和之后部分的<code>ssub_match</code>对象。一个<code>ssub_match</code>对象有两个名为<code>str</code>和<code>length</code>的成员，分别返回匹配的<code>string</code>和该<code>string</code>的长度。</p>
<h3 id="使用子表达式"><a href="#使用子表达式" class="headerlink" title="使用子表达式"></a>使用子表达式</h3><p>正则表达式中的模式通常包含一个或多个子表达式。子表达式是模式的一部分，本身也有意义。正则表达式语法通常用括号表示子表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;([[:alnum:]]+)\\.(cpp|cxx|cc)$&quot;</span>, regex::icase)</span></span>;</span><br></pre></td></tr></table></figure>

<p>匹配对象除了提供匹配整体的相关信息外，还可以用来访问模式中的每个子表达式。子匹配是按位置来访问的，第一个子匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。</p>
<p>子表达式的一个常见用途是验证必须匹配特定格式的数据，如电话号码和电子邮箱地址。</p>
<p>ECMAScript正则表达式语言的一些特性：</p>
<ul>
<li><p>模式<code>[[:alnum:]]</code>匹配任意字母。</p>
</li>
<li><p>符号<code>+</code>表示匹配一个或多个字符。</p>
</li>
<li><p>符号<code>*</code>表示匹配零个或多个字符。</p>
</li>
<li><p><code>\&#123;d&#125;</code>表示单个数字，<code>\&#123;d&#125;&#123;n&#125;</code>表示一个n个数字的序列。</p>
</li>
<li><p>在方括号中的字符集合表示匹配这些字符中的任意一个。</p>
</li>
<li><p>后接<code>?</code>的组件是可选的。</p>
</li>
<li><p>类似C++，ECMAScript使用反斜线进行转义。由于模式包含括号，而括号是ECMAScript中的特殊字符，因此需要用<code>\(</code>和<code>\)</code>来表示括号是模式的一部分。</p>
</li>
</ul>
<p>因为反斜线<code>\</code>是C++中的特殊字符，所以在模式中使用<code>\</code>时，需要一个额外的反斜线进行转义。</p>
<p>子匹配操作：</p>
<h3 id="使用regex-replace"><a href="#使用regex-replace" class="headerlink" title="使用regex_replace"></a>使用<code>regex_replace</code></h3><p>正则表达式替换操作：</p>
<p>标准库定义了用于在正则表达式替换过程中控制匹配或格式的标志。这些标志可以传递给<code>regex_search</code>、<code>regex_match</code>函数或者<code>smatch</code>类的<code>format</code>成员。匹配和格式化标志的类型为<code>match_flag_type</code>，定义在命名空间<code>regex_constants</code>中。由于<code>regex_constants</code>定义在<code>std</code>中，因此在使用这些名字时，需要同时加上两个命名空间的限定符。</p>
<p>默认情况下，<code>regex_replace</code>输出整个输入序列。未与正则表达式匹配的部分会原样输出，匹配的部分按照格式字符串指定的格式输出。使用<code>format_no_copy</code>标志可以只输出匹配部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string fmt2 = <span class="string">&quot;$2.$5.$7 &quot;</span>;    <span class="comment">// put space after the last number as a separator</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">regex_replace</span>(s, r, fmt2, format_no_copy) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>在新标准出现之前，C和C++都依赖于一个简单的C库函数<code>rand</code>来生成随机数。该函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。</p>
<p>头文件<code>random</code>中的随机数库定义了一组类来解决<code>rand</code>函数的一些问题：随机数引擎类（random-number engines）可以生成<code>unsigned</code>随机数序列；随机数分布类（random-number distribution classes）使用引擎类生成指定类型、范围和概率分布的随机数。</p>
<p><img src="/Images/17-17.png" alt="17-17"></p>
<p>C++程序不应该使用<code>rand</code>函数，而应该使用<code>default_random_engine</code>类和恰当的分布类对象。</p>
<h3 id="随机数引擎和分布"><a href="#随机数引擎和分布" class="headerlink" title="随机数引擎和分布"></a>随机数引擎和分布</h3><p>随机数引擎是函数对象类，定义了一个不接受参数的调用运算符，返回一个随机<code>unsigned</code>整数。调用一个随机数引擎对象可以生成原始随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    cout &lt;&lt; <span class="built_in">e</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>标准库定义了多个随机数引擎类，区别在于性能和随机性质量。每个编译器都会指定其中一个作为<code>default_random_engine</code>类型，此类型一般具有最常用的特性。</p>
<p>大多数情况下，随机数引擎的输出是不能直接使用的，因为生成的随机数范围通常与程序所需要的不符。</p>
<p>使用分布类对象可以得到指定范围的随机数。新标准库的<code>uniform_int_distribution&lt;unsigned&gt;</code>类型生成均匀分布的<code>unsigned</code>值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">uniform_int_distribution&lt;<span class="type">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">default_random_engine e;    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    cout &lt;&lt; <span class="built_in">u</span>(e) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>类似引擎类型，分布类型也是函数对象类。分布类型定义了一个接受一个随机数引擎参数的调用运算符。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布区间。</p>
<p>随机数发生器指分布对象和引擎对象的组合。</p>
<p><code>rand</code>函数的生成范围在0到<code>RAND_MAX</code>之间，随机数引擎生成的<code>unsigned</code>整数在一个系统定义的范围内。一个引擎类型的范围可以通过调用该类型对象的<code>min</code>和<code>max</code>成员来获得。</p>
<p>即使随机数发生器生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序时它都会返回相同的数值序列。</p>
<p>如果函数需要局部的随机数发生器，应该将其（包括引擎和分布对象）定义为<code>static</code>对象，这样随机数发生器就能在函数调用期间保持状态。否则每次调用函数都会生成相同的序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">good_randVec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> default_random_engine e;</span><br><span class="line">    <span class="function"><span class="type">static</span> uniform_int_distribution&lt;<span class="type">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">unsigned</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">        ret.<span class="built_in">push_back</span>(<span class="built_in">u</span>(e));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过为引擎提供一个种子（seed），可以让引擎在程序每次运行时生成不同的序列。种子是一个数值，引擎利用它从序列中的一个新位置重新开始生成随机数。</p>
<p>为引擎设置种子有两种方式：</p>
<ul>
<li><p>在创建对象时提供种子。</p>
</li>
<li><p>调用引擎的<code>seed</code>成员设置种子。</p>
</li>
</ul>
<p>选择种子的常用方法是调用系统函数<code>time</code>。该函数定义在头文件<code>ctime</code>中，返回从一个特定时刻到当前经过的秒数。<code>time</code>函数接受单个指针参数，指向用于写入时间的数据结构。如果指针为空，则函数简单地返回时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e1</span><span class="params">(time(<span class="number">0</span>))</span></span>;   </span><br></pre></td></tr></table></figure>

<p>由于<code>time</code>函数返回以秒计算的时间，因此用<code>time</code>返回值作为种子的方式只适用于生成种子的间隔为秒级或更长时间的应用。另外如果程序作为一个自动过程的一部分反复运行，这种方式也会无效，可能多次使用的是相同的种子。</p>
<h3 id="其他随机数分布"><a href="#其他随机数分布" class="headerlink" title="其他随机数分布"></a>其他随机数分布</h3><p>从<code>rand</code>函数获得随机浮点数的一个常用但不正确的方法是用<code>rand</code>的结果除以<code>RAND_MAX</code>。但因为随机整数的精度通常低于随机浮点数，所以使用这种方法时，有一些浮点值永远不会被生成。</p>
<p>使用新标准库的<code>uniform_real_distribution</code>类型可以获得随机浮点数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;   </span><br><span class="line"><span class="function">uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    cout &lt;&lt; <span class="built_in">u</span>(e) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>分布类型操作：</p>
<p>除了总是生成<code>bool</code>类型的<code>bernouilli_distribution</code>外，其他分布类型都是模板。每个模板都接受单个类型参数，指定分布生成的结果类型。</p>
<p>分布类型限制了可以作为模板类型的参数类型，一些模板只能生成浮点数，而其他模板只能生成整数。分布类型还定义了一个默认模板类型参数，整型分布的默认参数是<code>int</code>，浮点数分布的默认参数是<code>double</code>。使用默认类型时应该在模板名后使用空尖括号。</p>
<p><code>bernouilli_distribution</code>类型是一个普通类，而非模板。该分布返回一个<code>bool</code>值，其中<code>true</code>的概率是一个常数，默认为0.5。</p>
<p>由于引擎会返回相同的随机数序列，因此需要在循环中使用引擎时，必须在循环体外定义引擎对象。否则每次循环都会创建新引擎，生成相同序列。同样，分布对象也需要保持运行状态，也必须在循环体外定义。</p>
<h2 id="IO库再探"><a href="#IO库再探" class="headerlink" title="IO库再探"></a>IO库再探</h2><h3 id="格式化输入与输出"><a href="#格式化输入与输出" class="headerlink" title="格式化输入与输出"></a>格式化输入与输出</h3><p>除了条件状态外，每个<code>iostream</code>对象还维护着一个格式状态来控制IO格式化细节。</p>
<p>标准库定义了一组操纵符（manipulator）来修改流的格式状态。操纵符是一个函数或对象，会影响流的状态，并能作为输入和输出运算符的运算对象。类似输入和输出运算符，操纵符也返回它所处理的流对象。</p>
<p>操纵符用于两大类输出控制：控制数值的输出格式，控制补白的数量和位置。</p>
<p>操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。大多数改变格式状态的操纵符都是设置&#x2F;复原成对的，一个操纵符用于设置新格式，另一个用于恢复正常格式。</p>
<p>默认情况下，<code>bool</code>值输出为1（<code>true</code>）或0（<code>false</code>）。对流使用<code>boolalpha</code>操纵符可以输出<code>true</code>或<code>false</code>，还原格式时使用<code>noboolalpha</code>操纵符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;default bool values: &quot;</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="literal">false</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;\nalpha bool values: &quot;</span> &lt;&lt; boolalpha</span><br><span class="line">    &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default bool values: 1 0</span><br><span class="line">alpha bool values: true false</span><br></pre></td></tr></table></figure>

<p>默认情况下，整型值的输入输出使用十进制。可以使用<code>hex</code>、<code>oct</code>和<code>dec</code>操纵符将其改为十六进制、八进制或改回十进制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;default: &quot;</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;octal: &quot;</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hex: &quot;</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;decimal: &quot;</span> &lt;&lt; dec &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default: 20 1024</span><br><span class="line">octal: 24 2000</span><br><span class="line">hex: 14 400</span><br><span class="line">decimal: 20 1024</span><br></pre></td></tr></table></figure>

<p><code>hex</code>、<code>oct</code>和<code>dec</code>操纵符只影响整型运算对象，浮点值的表示形式不受影响。</p>
<p>默认情况下，在输出数值时，没有可见的标识指出当前使用的进制模式。如果需要输出八进制或十六进制值，应该使用<code>showbase</code>操纵符。对流应用<code>showbase</code>后，在输出结果中会显示进制，显示模式和指定整型常量进制的规范相同。</p>
<ul>
<li><p>前导<code>0x</code>表示十六进制。</p>
</li>
<li><p>前导<code>0</code>表示八进制。</p>
</li>
<li><p>无前导字符表示十进制。</p>
</li>
</ul>
<p>还原格式时使用<code>noshowbase</code>操纵符。</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default: 20 1024</span><br><span class="line">in octal: 024 02000</span><br><span class="line">in hex: 0x14 0x400</span><br><span class="line">in decimal: 20 1024</span><br></pre></td></tr></table></figure>

<p>默认情况下，十六进制值（包括前导字符）以小写格式输出。使用<code>uppercase</code>操纵符可以输出大写字母。还原格式时使用<code>nouppercase</code>操纵符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex</span><br><span class="line">    &lt;&lt; <span class="string">&quot;printed in hexadecimal: &quot;</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1024</span></span><br><span class="line">    &lt;&lt; nouppercase &lt;&lt; noshowbase &lt;&lt; dec &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>浮点数的输出格式涉及三个方面：</p>
<ul>
<li><p>输出精度（即输出多少个数字）。</p>
</li>
<li><p>十六进制、定点十进制或者科学记数法形式输出。</p>
</li>
<li><p>没有小数部分的浮点值是否输出小数点。</p>
</li>
</ul>
<p>默认情况下，浮点值按六位数字精度输出；如果浮点值没有小数部分，则不输出小数点；根据浮点数的值选择输出为定点十进制或科学计数法形式：非常大或非常小的值输出为科学记数法形式，其他值输出为定点十进制形式。</p>
<p>默认情况下，精度控制输出的数字总位数。输出时，浮点值按照当前精度四舍五入而非截断。</p>
<p>调用IO对象的<code>precision</code>成员或者使用<code>setprecision</code>操纵符可以改变精度。</p>
<ul>
<li><p><code>precision</code>成员是重载的。一个版本接受一个<code>int</code>值，将精度设置为此值，并返回旧精度值。另一个版本不接受参数，直接返回当前精度值。</p>
</li>
<li><p><code>setprecision</code>操纵符接受一个参数来设置精度。</p>
</li>
</ul>
<p><code>setprecision</code>操纵符和其他接受参数的操纵符都定义在头文件<code>iomanip</code>中。</p>
<p>操纵符可以强制流使用科学记数法、定点十进制或十六进制形式输出浮点值。</p>
<ul>
<li><p><code>scientific</code>使用科学记数法表示浮点值。</p>
</li>
<li><p><code>fixed</code>使用定点十进制表示浮点值。</p>
</li>
<li><p><code>hexfloat</code>（新标准库）使用十六进制表示浮点值。</p>
</li>
<li><p><code>defaultfloat</code>（新标准库）将流恢复到默认状态。</p>
</li>
</ul>
<p>除非程序需要控制浮点数的表示方式，否则最好由标准库来选择计数法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;default format: &quot;</span> &lt;&lt; <span class="number">100</span> * <span class="built_in">sqrt</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;scientific: &quot;</span> &lt;&lt; scientific &lt;&lt; <span class="number">100</span> * <span class="built_in">sqrt</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;fixed decimal: &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="number">100</span> * <span class="built_in">sqrt</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;hexadecimal: &quot;</span> &lt;&lt; hexfloat &lt;&lt; <span class="number">100</span> * <span class="built_in">sqrt</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;use defaults: &quot;</span> &lt;&lt; defaultfloat &lt;&lt; <span class="number">100</span> * <span class="built_in">sqrt</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default format: 141.421</span><br><span class="line">scientific: 1.414214e+002</span><br><span class="line">fixed decimal: 141.421356</span><br><span class="line">hexadecimal: 0x1.1ad7bcp+7</span><br><span class="line">use defaults: 141.421</span><br></pre></td></tr></table></figure>

<p><code>scientific</code>、<code>fixed</code>和<code>hexfloat</code>操纵符会改变流的精度含义。执行这些操纵符后，精度控制的将是小数点后面的数字位数，而默认情况下控制的是数字总位数。</p>
<p>默认情况下，当浮点值的小数部分为0时，不显示小数点。使用<code>showpoint</code>操纵符可以强制输出小数点，<code>noshowpoint</code>操纵符还原默认行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">10.0</span> &lt;&lt; endl;        <span class="comment">// prints 10</span></span><br><span class="line">cout &lt;&lt; showpoint &lt;&lt; <span class="number">10.0</span>    <span class="comment">// prints 10.0000</span></span><br><span class="line">    &lt;&lt; noshowpoint &lt;&lt; endl;  <span class="comment">// revert to default format for the decimal point</span></span><br></pre></td></tr></table></figure>

<p>按列输出时，通常需要非常精细地控制数据格式。</p>
<ul>
<li><p><code>setw</code>指定下一个数字或字符串值的最小空间。</p>
</li>
<li><p><code>left</code>表示左对齐输出。</p>
</li>
<li><p><code>right</code>表示右对齐输出（默认格式）。</p>
</li>
<li><p><code>internal</code>控制负数的符号位置，它左对齐符号，右对齐值，中间空间用空格填充。</p>
</li>
<li><p><code>setfill</code>指定一个字符代替默认的空格进行补白。</p>
</li>
</ul>
<p><code>setw</code>类似<code>endl</code>，不改变输出流的内部状态，只影响下一次输出的大小。</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i: -16next col</span><br><span class="line">d: 3.14159next col</span><br><span class="line">i: -16 next col</span><br><span class="line">d: 3.14159 next col</span><br><span class="line">i: -16next col</span><br><span class="line">d: 3.14159next col</span><br><span class="line">i: - 16next col</span><br><span class="line">d: 3.14159next col</span><br><span class="line">i: -#########16next col</span><br><span class="line">d: #####3.14159next col</span><br></pre></td></tr></table></figure>

<p>默认情况下，输入运算符会忽略空白字符（空格符、制表符、换行符、换纸符和回车符）。使用<code>noskipws</code>操纵符可以让输入运算符读取空白符，<code>skipws</code>操纵符还原默认行为。</p>
<h3 id="未格式化操作"><a href="#未格式化操作" class="headerlink" title="未格式化操作"></a>未格式化操作</h3><p>标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这些操作可以将一个流当作无解释的字节序列来处理。</p>
<p>一些未格式化操作每次处理流的一个字节，它们会读取而不是忽略空白符。</p>
<p>使用未格式化IO操作<code>get</code>和<code>put</code>可以读取和写入一个字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (cin.<span class="built_in">get</span>(ch))</span><br><span class="line">    cout.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></table></figure>

<p>有时读取完一个字符后才发现目前无法处理该字符，希望将其放回流中。标准库提供了三种方法退回字符。</p>
<ul>
<li><p><code>peek</code>返回输入流中下一个字符的副本，但不会将其从流中删除。</p>
</li>
<li><p><code>unget</code>使输入流向后移动，令最后读取的值回到流中。即使不知道最后从流中读取了什么值，也可以调用<code>unget</code>。</p>
</li>
<li><p><code>putback</code>是特殊版本的<code>unget</code>，它退回从流中读取的最后一个值，但它接受一个参数，该参数必须与最后读取的值相同。</p>
</li>
</ul>
<p>一般情况下，在读取下一个值之前，标准库保证程序可以退回最多一个值。</p>
<p><code>peek</code>和无参数的<code>get</code>函数都以<code>int</code>类型从输入流返回字符。这些函数使用<code>int</code>的原因是可以返回文件尾标记。<code>char</code>范围中的每个值都表示一个真实字符，因此没有额外的值可以表示文件尾。返回<code>int</code>的函数先将要返回的字符转换为<code>unsigned char</code>，再将结果提升为<code>int</code>。因此即使字符集中有字符映射到负值，返回的<code>int</code>也是正值。而标准库使用负值表示文件尾，这样就能保证文件尾与任何合法字符的值都不相同。头文件<code>cstdio</code>定义了一个名为<code>EOF</code>的常量值，可以用它检测函数返回的值是否是文件尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch; </span><br><span class="line"><span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">    cout.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></table></figure>

<p>一个常见的编程错误是将<code>get</code>或<code>peek</code>函数的返回值赋给<code>char</code>而非<code>int</code>对象，但编译器不能发现这个错误。</p>
<p>当<code>get</code>返回<code>EOF</code>时，该值会先被转换为<code>unsigned char</code>，之后提升得到的<code>int</code>值与<code>EOF</code>值不再相等，因此循环永远不会停止。</p>
<p>一些未格式化IO操作一次处理大块数据，这些操作可以提高程序执行速度，但需要自己分配并管理用来保存和提取数据的字符数组。</p>
<p><code>get</code>和<code>getline</code>函数接受相同的参数，它们的行为类似但不相同。两个函数都一直读取数据，直到遇到下列情况之一：</p>
<ul>
<li><p>已经读取了<code>size - 1</code>个字符。</p>
</li>
<li><p>遇到了文件尾（<code>EOF</code>）。</p>
</li>
<li><p>遇到了分隔符。</p>
</li>
</ul>
<p>两个函数的区别在于处理分隔符的方式：<code>get</code>将分隔符留在输入流中作为下一个字符，而<code>getline</code>读取并丢弃分隔符。两个函数都不会将分隔符保存在结果数组中。</p>
<p>读取流数据时的一个常见错误是忘记从流中删除分隔符。</p>
<p>一些操作可能从输入流中读取了未知个数的字节，使用<code>gcount</code>函数可以确定上一次未格式化输入操作读取了多少字符。<code>gcount</code>函数应该在任何后续未格式化输入操作前调用，将字符退回流的操作也属于未格式化输入操作。如果在调用<code>gcount</code>前使用了<code>peek</code>、<code>unget</code>或<code>putback</code>操作，则<code>gcount</code>的返回值为0。</p>
<p>使用<code>clear</code>、<code>ignore</code>和<code>sync</code>函数可以清空输入流中的数据。读到非法字符时，输入流将处于错误状态。为了继续获取输入数据，先调用<code>clear</code>函数重置流的错误标记。再调用<code>ignore</code>清空流中指定大小的数据，或者调用<code>sync</code>直接清空流中所有数据。<code>numeric_limits&lt;streamsize&gt;::max()</code>返回流的缓冲区大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置错误标志</span></span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除流中所有数据</span></span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line">cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除流中一行数据</span></span><br><span class="line">cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="流随机访问"><a href="#流随机访问" class="headerlink" title="流随机访问"></a>流随机访问</h3><p>随机IO本质上是依赖于操作系统的。</p>
<p>为了支持随机访问，IO类型通过维护一个标记来确定下一次读写操作的位置。<code>seek</code>函数用于移动标记，<code>tell</code>函数用于获取标记。标准库实际上定义了两对<code>seek</code>和<code>tell</code>函数，一对用于输入流（后缀为<code>g</code>，表示get），一对用于输出流（后缀为<code>p</code>，表示put）。</p>
<p>虽然标准库为所有流类型都定义了<code>seek</code>和<code>tell</code>函数，但它们是否有意义取决于流绑定到哪个设备。在大多数系统中，绑定到<code>cin</code>、<code>cout</code>、<code>cerr</code>和<code>clog</code>的流不支持随机访问。对这些流可以调用<code>seek</code>和<code>tell</code>函数，但在运行时会出现错误，流也会被置为无效状态。</p>
<p>从逻辑上考虑，<code>seek</code>和<code>tell</code>函数的使用范围如下：</p>
<ul>
<li><p>可以对<code>istream</code>、<code>ifstream</code>、<code>istringstream</code>类型使用<code>g</code>版本。</p>
</li>
<li><p>可以对<code>ostream</code>、<code>ofstream</code>、<code>ostringstream</code>类型使用<code>p</code>版本。</p>
</li>
<li><p>可以对<code>iostream</code>、<code>fstream</code>、<code>stringstream</code>类型使用<code>g</code>和<code>p</code>版本。</p>
</li>
</ul>
<p>一个流中只有一个标记——不存在独立的读标记和写标记。<code>fstream</code>和<code>stringstream</code>类型可以读写同一个流。在这些类型中，有单一的缓冲区用于保存读写的数据，同时标记也只有一个，表示缓冲区中的当前位置。标准库将两个版本的<code>seek</code>和<code>tell</code>函数都映射到这个标记。</p>
<p>由于流中只有一个标记，因此在切换读写操作时，必须使用<code>seek</code>函数来重定位标记。</p>
<p><code>seek</code>函数有两个重载版本：一个版本使用绝对地址移动流标记；另一个版本使用指定位置和偏移量移动流标记。</p>
<p>参数<code>new_position</code>和<code>offset</code>的类型分别是<code>pos_type</code>和<code>off_type</code>，这两个类型都是机器相关的，定义在头文件<code>istream</code>和<code>ostream</code>中。<code>pos_type</code>表示文件位置，而<code>off_type</code>表示距离当前位置的偏移量，偏移量可以是正数也可以是负数。</p>
<p><code>tellg</code>和<code>tellp</code>函数返回一个<code>pos_type</code>值，表示流的当前位置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/14/C++%20Primer%20Chapter%2016%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/14/C++%20Primer%20Chapter%2016%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 16 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-14 14:02:15" itemprop="dateCreated datePublished" datetime="2023-06-14T14:02:15+08:00">2023-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-06 10:09:48" itemprop="dateModified" datetime="2023-08-06T10:09:48+08:00">2023-08-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第16章-模板与泛型编程"><a href="#第16章-模板与泛型编程" class="headerlink" title="第16章 模板与泛型编程"></a>第16章 模板与泛型编程</h1><h2 id="模板定义"><a href="#模板定义" class="headerlink" title="模板定义"></a>模板定义</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板可以用来生成针对特定类型的函数版本。</p>
<p>模板定义以关键字<code>template</code>开始，后跟一个模板参数列表。模板参数列表以尖括号<code>&lt;&gt;</code>包围，内含用逗号分隔的一个或多个模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义模板时，模板参数列表不能为空。</p>
<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，需要显式或隐式地指定模板实参，并将其绑定到模板参数上。</p>
<p>使用函数模板时，编译器用推断出的模板参数来实例化一个特定版本的函数，这些生成的函数通常被称为模板的实例。</p>
<p>模板类型参数（type parameter）可以用来指定函数的返回类型或参数类型，以及在函数体内用于变量声明和类型转换。类型参数前必须使用关键字<code>class</code>或<code>typename</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = *p; </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> U&amp;)</span></span>;</span><br><span class="line"><span class="comment">// ok: </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">calc</span> (<span class="type">const</span> T&amp;, <span class="type">const</span> U&amp;);</span><br></pre></td></tr></table></figure>

<p>建议使用<code>typename</code>而不是<code>class</code>来指定模板类型参数，这样更加直观。</p>
<p>模板非类型参数（nontype parameter）需要用特定的类型名来指定，表示一个值而非一个类型。非类型参数可以是整型、指向对象或函数类型的指针或左值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[<span class="number">3</span>], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[<span class="number">4</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>绑定到整型非类型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期，不能用普通局部变量或动态对象作为指针或引用非类型参数的实参。</p>
<p>函数模板也可以声明为<code>inline</code>或<code>constexpr</code>的，说明符放在模板参数列表之后，返回类型之前。</p>
<p>模板程序应该尽量减少对实参类型的要求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">less</span>&lt;T&gt;()(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">less</span>&lt;T&gt;()(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当模板的一个特定版本被实例化时，编译器才会生成代码。此时编译器需要掌握生成代码所需的信息，因此函数模板和类模板成员函数的定义通常放在头文件中。</p>
<p>使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的设计者来保证的。模板设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。</p>
<p>调用者负责保证传递给模板的实参能正确支持模板所要求的操作。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>使用一个类模板时，必须提供显式模板实参列表，编译器使用这些模板实参来实例化出特定的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t)); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个类模板的每个实例都形成一个独立的类，相互之间没有关联。</p>
<p>如果一个类模板中的代码使用了另一个模板，通常不会将一个实际类型（或值）的名字用作其模板实参，而是将模板自己的参数用作被使用模板的实参。</p>
<p>类模板的成员函数具有和类模板相同的模板参数，因此定义在类模板外的成员函数必须以关键字<code>template</code>开始，后跟类模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member-<span class="built_in">name</span>(parm-list)</span><br></pre></td></tr></table></figure>

<p>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。</p>
<p>在类模板自己的作用域内，可以直接使用模板名而不用提供模板实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类模板作用域内不需要写成BlobPtr&lt;T&gt;形式</span></span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义时需要提供模板实参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 进入类模板作用域</span></span><br><span class="line">    BlobPtr Ret = *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个类包含一个友元声明时，类与友元各自是否是模板并无关联。如果一个类模板包含一个非模板友元，则友元可以访问所有类模板实例。如果友元自身是模板，则类可以给所有友元模板实例授予访问权限，也可以只授权给特定实例。</p>
<ul>
<li><p>一对一友元关系</p>
<p>为了引用模板的一个特定实例，必须首先声明模板自身。模板声明包括模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>;    </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BlobPtr</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通用和特定的模板友元关系</p>
<p>为了让模板的所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</p>
</li>
</ul>
<p>C++11中，类模板可以将模板类型参数声明为友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> Type;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11允许使用<code>using</code>为类模板定义类型别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;   </span><br></pre></td></tr></table></figure>

<p>类模板可以声明<code>static</code>成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::<span class="type">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::<span class="type">size_t</span> ctr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi, fi2, fi3;</span><br></pre></td></tr></table></figure>

<p>类模板的每个实例都有一个独有的<code>static</code>对象，而每个<code>static</code>成员必须有且只有一个定义。因此与定义模板的成员函数类似，<code>static</code>成员也应该定义成模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>;   </span><br></pre></td></tr></table></figure>

<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板参数遵循普通的作用域规则。与其他任何名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是在模板内不能重用模板参数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A tmp = a;   </span><br><span class="line">    <span class="type">double</span> B;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于模板参数名不能重用，所以一个名字在一个特定模板参数列表中只能出现一次。</p>
<p>与函数参数一样，声明中模板参数的名字不必与定义中的相同。</p>
<p>一个特定文件所需要的所有模板声明通常一起放置在文件开始位置，出现在任何使用这些模板的代码之前。</p>
<p>模板中的代码使用作用域运算符<code>::</code>时，编译器无法确定其访问的名字是类型还是<code>static</code>成员。</p>
<p>默认情况下，C++假定模板中通过作用域运算符访问的名字是<code>static</code>成员。因此，如果需要使用一个模板类型参数的类型成员，就必须使用关键字<code>typename</code>显式地告知编译器该名字是一个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!c.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::<span class="built_in">value_type</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++11允许为函数和类模板提供默认实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2, F f = <span class="built_in">F</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类模板为其所有模板参数都提供了默认实参，在使用这些默认实参时，必须在模板名后面跟一个空尖括号对<code>&lt;&gt;</code>。</p>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>一个类（无论是普通类还是模板类）可以包含本身是模板的成员函数，这种成员被称为成员模板。成员模板不能是虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DebugDelete</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DebugDelete</span>(std::ostream &amp;s = std::cerr): <span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ostream &amp;os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="built_in">Blob</span>(It b, It e);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">// type parameter for the class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;  <span class="comment">// type parameter for the constructor</span></span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(It b, It e):</span><br><span class="line">    <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e))</span><br><span class="line">    &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>为了实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。</p>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>因为模板在使用时才会进行实例化，所以相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中都会有该模板的一个实例。</p>
<p>在大型程序中，多个文件实例化相同模板的额外开销可能非常严重。C++11允许通过显式实例化（explicit instantiation）来避免这种开销。</p>
<p>显式实例化的形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;   </span><br><span class="line"><span class="keyword">template</span> declaration;          </span><br></pre></td></tr></table></figure>

<p><code>declaration</code>是一个类或函数声明，其中所有模板参数已被替换为模板实参。当编译器遇到<code>extern</code>模板声明时，它不会在本文件中生成实例化代码。对于一个给定的实例化版本，可能有多个<code>extern</code>声明，但必须只有一个定义。</p>
<p>当编译器遇到类模板的实例化定义时，它不清楚程序会使用哪些成员函数。和处理类模板的普通实例化不同，编译器会实例化该模板的所有成员，包括内联的成员函数。因此，用来显式实例化类模板的类型必须能用于模板的所有成员。</p>
<h3 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h3><p><code>unique_ptr</code>在编译时绑定删除器，避免了间接调用删除器的运行时开销。<code>shared_ptr</code>在运行时绑定删除器，使用户重载删除器的操作更加简便。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>对于函数模板，编译器通过调用的函数实参来确定其模板参数。这个过程被称作模板实参推断。</p>
<h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>与非模板函数一样，调用函数模板时传递的实参被用来初始化函数的形参。如果一个函数形参的类型使用了模板类型参数，则会采用特殊的初始化规则，只有有限的几种类型转换会自动地应用于这些实参。编译器通常会生成新的模板实例而不是对实参进行类型转换。</p>
<p>有3种类型转换可以在调用中应用于函数模板：</p>
<ul>
<li><p>顶层<code>const</code>会被忽略。</p>
</li>
<li><p>可以将一个非<code>const</code>对象的引用或指针传递给一个<code>const</code>引用或指针形参。</p>
</li>
<li><p>如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。数组实参可以转换为指向其首元素的指针。函数实参可以转换为该函数类型的指针。</p>
</li>
</ul>
<p>其他的类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
<p> 一个模板类型参数可以作为多个函数形参的类型。由于允许的类型转换有限，因此传递给这些形参的实参必须具有相同的类型，否则调用失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng, <span class="number">1024</span>);   <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>如果想增强函数的兼容性，可以使用两个类型参数定义函数模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">flexibleCompare</span><span class="params">(<span class="type">const</span> A&amp; v1, <span class="type">const</span> B&amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> lng;</span><br><span class="line"><span class="built_in">flexibleCompare</span>(lng, <span class="number">1024</span>);   </span><br></pre></td></tr></table></figure>

<p>函数模板中使用普通类型定义的参数可以进行正常的类型转换。</p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>显式模板实参（explicit template argument）可以让用户自己控制模板的实例化。提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在尖括号<code>&lt;&gt;</code>中指定，位于函数名之后，实参列表之前。</p>
<p>显式模板实参按照从左到右的顺序与对应的模板参数匹配，只有尾部参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。</p>
<p>对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng, <span class="number">1024</span>);         <span class="comment">// error: template parameters don&#x27;t match</span></span><br><span class="line"><span class="built_in">compare</span>&lt;<span class="type">long</span>&gt;(lng, <span class="number">1024</span>);   <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">compare</span>&lt;<span class="type">int</span>&gt;(lng, <span class="number">1024</span>);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><p>由于尾置返回出现在函数列表之后，因此它可以使用函数参数来声明返回类型。</p>
<p>标准库在头文件<code>type_traits</code>中定义了类型转换模板，这些模板常用于模板元程序设计。其中每个模板都有一个名为<code>type</code>的公有类型成员，表示一个类型。此类型与模板自身的模板类型参数相关。如果不可能（或不必要）转换模板参数，则<code>type</code>成员就是模板参数类型本身。</p>
<p>使用<code>remove_reference</code>可以获得引用对象的元素类型，如果用一个引用类型实例化<code>remove_reference</code>，则<code>type</code>表示被引用的类型。因为<code>type</code>是一个类的类型成员，所以在模板中必须使用关键字<code>typename</code>来告知编译器其表示一个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> *beg;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>使用函数模板初始化函数指针或为函数指针赋值时，编译器用指针的类型来推断模板实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="built_in">int</span> (*pf1)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>

<p>如果编译器不能从函数指针类型确定模板实参，则会产生错误。使用显式模板实参可以消除调用歧义。</p>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><p>当一个函数参数是模板类型参数的普通（左值）引用（形如<code>T&amp;</code>）时，只能传递给它一个左值（如一个变量或一个返回引用类型的表达式）。<code>T</code>被推断为实参所引用的类型，如果实参是<code>const</code>的，则<code>T</code>也为<code>const</code>类型。</p>
<p>当一个函数参数是模板类型参数的常量引用（形如<code>const T&amp;</code>）时，可以传递给它任何类型的实参。函数参数本身是<code>const</code>时，<code>T</code>的类型推断结果不会是<code>const</code>类型。<code>const</code>已经是函数参数类型的一部分了，因此不会再是模板参数类型的一部分。</p>
<p>当一个函数参数是模板类型参数的右值引用（形如<code>T&amp;&amp;</code>）时，如果传递给它一个右值，类型推断过程类似普通左值引用函数参数的推断过程，推断出的<code>T</code>类型是该右值实参的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>);    </span><br></pre></td></tr></table></figure>

<p>模板参数绑定的两个例外规则：</p>
<ul>
<li><p>如果将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时，编译器推断模板类型参数为实参的左值引用类型。</p>
</li>
<li><p>如果间接创建了一个引用的引用（通过类型别名或者模板类型参数间接定义），则这些引用会被“折叠”。右值引用的右值引用会被折叠为右值引用。其他情况下，引用都被折叠为普通左值引用。</p>
<table>
<thead>
<tr>
<th align="center">折叠前</th>
<th align="center">折叠后</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>T&amp; &amp;</code>、<code>T&amp; &amp;&amp;</code>、<code>T&amp;&amp; &amp;</code></td>
<td align="center"><code>T&amp;</code></td>
</tr>
<tr>
<td align="center"><code>T&amp;&amp; &amp;&amp;</code></td>
<td align="center"><code>T&amp;&amp;</code></td>
</tr>
</tbody></table>
</li>
</ul>
<p>模板参数绑定的两个例外规则导致了两个结果：</p>
<ul>
<li><p>如果一个函数参数是指向模板类型参数的右值引用，则可以传递给它任意类型的实参。</p>
</li>
<li><p>如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用。</p>
</li>
</ul>
<p>当代码中涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = val;    </span><br><span class="line">    t = <span class="built_in">fcn</span>(t);   </span><br><span class="line">    <span class="keyword">if</span> (val == t) &#123; <span class="comment">/* ... */</span> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际编程中，模板的右值引用参数通常用于两种情况：模板转发其实参或者模板被重载。函数模板的常用重载形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;        </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;   </span><br></pre></td></tr></table></figure>

<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解<code>std::move</code></h3><p><code>std::move</code>的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::move</code>的工作过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hi!&quot;</span>)</span>, s2</span>;</span><br><span class="line">s2 = std::<span class="built_in">move</span>(<span class="built_in">string</span>(<span class="string">&quot;bye!&quot;</span>));     </span><br><span class="line">s2 = std::<span class="built_in">move</span>(s1);     </span><br></pre></td></tr></table></figure>

<ul>
<li><p>在<code>std::move(string(&quot;bye!&quot;))</code>中传递的是右值。</p>
<ul>
<li><p>推断出的<code>T</code>类型为<code>string</code>。</p>
</li>
<li><p><code>remove_reference</code>用<code>string</code>进行实例化。</p>
</li>
<li><p><code>remove_reference&lt;string&gt;</code>的<code>type</code>成员是<code>string</code>。</p>
</li>
<li><p><code>move</code>的返回类型是<code>string&amp;&amp;</code>。</p>
</li>
<li><p><code>move</code>的函数参数<code>t</code>的类型为<code>string&amp;&amp;</code>。</p>
</li>
</ul>
</li>
<li><p>在<code>std::move(s1)</code>中传递的是左值。</p>
<ul>
<li><p>推断出的<code>T</code>类型为<code>string&amp;</code>。</p>
</li>
<li><p><code>remove_reference</code>用<code>string&amp;</code>进行实例化。</p>
</li>
<li><p><code>remove_reference&lt;string&amp;&gt;</code>的<code>type</code>成员是<code>string</code>。</p>
</li>
<li><p><code>move</code>的返回类型是<code>string&amp;&amp;</code>。</p>
</li>
<li><p><code>move</code>的函数参数<code>t</code>的类型为<code>string&amp; &amp;&amp;</code>，会折叠成<code>string&amp;</code>。</p>
</li>
</ul>
</li>
</ul>
<p>可以使用<code>static_cast</code>显式地将一个左值转换为一个右值引用。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在这种情况下，需要保持被转发实参的所有性质，包括实参的<code>const</code>属性以及左值&#x2F;右值属性。</p>
<p>上例中，<code>j</code>被传递给<code>flip1</code>的参数<code>t1</code>，该参数是一个普通（非引用）类型<code>int</code>，而非<code>int&amp;</code>，因此<code>flip1(f, j, 42)</code>调用会被实例化为<code>void flip1(void(*fcn)(int, int&amp;), int t1, int t2)</code>。<code>j</code>的值被拷贝至<code>t1</code>中，<code>f</code>中的引用参数被绑定至<code>t1</code>，而非<code>j</code>，因此<code>j</code>不会被修改。</p>
<p>将函数参数定义为指向模板类型参数的右值引用（形如<code>T&amp;&amp;</code>），通过引用折叠，可以保持翻转实参的左值&#x2F;右值属性。并且引用参数（无论是左值还是右值）可以保持实参的<code>const</code>属性，因为在引用类型中的<code>const</code>是底层的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于修改后的版本，若调用<code>flip2(f, j, 42)</code>，会传递给参数<code>t1</code>一个左值<code>j</code>，但此时推断出的<code>T1</code>类型为<code>int&amp;</code>，<code>t1</code>的类型会被折叠为<code>int&amp;</code>，从而解决了<code>flip1</code>的错误。</p>
<p>但<code>flip2</code>只能用于接受左值引用的函数，不能用于接受右值引用的函数。函数参数与其他变量一样，都是左值表达式。所以即使是指向模板类型的右值引用参数也只能传递给接受左值引用的函数，不能传递给接受右值引用的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> &amp;&amp;i, <span class="type">int</span>&amp; j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="built_in">flip2</span>(g, i, <span class="number">42</span>); </span><br></pre></td></tr></table></figure>

<p>C++11在头文件<code>utility</code>中定义了<code>forward</code>。与<code>move</code>不同，<code>forward</code>必须通过显式模板实参调用，返回该显式实参类型的右值引用。即<code>forward&lt;T&gt;</code>返回类型<code>T&amp;&amp;</code>。</p>
<p>通常情况下，可以使用<code>forward</code>传递定义为指向模板类型参数的右值引用函数参数。通过其返回类型上的引用折叠，<code>forward</code>可以保持给定实参的左值&#x2F;右值属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="built_in">intermediary</span>(Type &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果实参是一个右值，则<code>Type</code>是一个普通（非引用）类型，<code>forward&lt;Type&gt;</code>返回类型<code>Type&amp;&amp;</code>。</p>
</li>
<li><p>如果实参是一个左值，则通过引用折叠，<code>Type</code>也是一个左值引用类型，<code>forward&lt;Type&gt;</code>返回类型<code>Type&amp;&amp; &amp;</code>，对返回类型进行引用折叠，得到<code>Type&amp;</code>。</p>
</li>
</ul>
<p>使用<code>forward</code>编写完善的转发函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>std::move</code>一样，对<code>std::forward</code>也不应该使用<code>using</code>声明。</p>
<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><p>函数模板可以被另一个模板或普通非模板函数重载。</p>
<p>如果重载涉及函数模板，则函数匹配规则会受到一些影响：</p>
<ul>
<li><p>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</p>
</li>
<li><p>候选的函数模板都是可行的，因为模板实参推断会排除任何不可行的模板。</p>
</li>
<li><p>和往常一样，可行函数（模板与非模板）按照类型转换（如果需要的话）来排序。但是可以用于函数模板调用的类型转换非常有限。</p>
</li>
<li><p>和往常一样，如果恰有一个函数提供比其他任何函数都更好的匹配，则选择此函数。但是如果多个函数都提供相同级别的匹配，则：</p>
<ul>
<li><p>如果同级别的函数中只有一个是非模板函数，则选择此函数。</p>
</li>
<li><p>如果同级别的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。</p>
</li>
<li><p>否则该调用有歧义。</p>
</li>
</ul>
</li>
</ul>
<p>通常，如果使用了一个没有声明的函数，代码将无法编译。但对于重载函数模板的函数而言，如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不再重要了。</p>
<p>在定义任何函数之前，应该声明所有重载的函数版本。这样编译器就不会因为未遇到你希望调用的函数而实例化一个并非你所需要的版本。</p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>可变参数模板指可以接受可变数量参数的模板函数或模板类。可变数量的参数被称为参数包（parameter pack），分为两种：</p>
<ul>
<li><p>模板参数包（template parameter pack），表示零个或多个模板参数。</p>
</li>
<li><p>函数参数包（function parameter pack），表示零个或多个函数参数。</p>
</li>
</ul>
<p>用一个省略号<code>…</code>来指出模板参数或函数参数表示一个包。在一个模板参数列表中，<code>class…</code>或<code>typename…</code>指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数列表。在函数参数列表中，如果一个参数的类型是模板参数包，则此参数也是函数参数包。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于一个可变参数模板，编译器会推断模板参数类型和参数数量。</p>
<p>可以使用<code>sizeof…</code>运算符获取参数包中的元素数量。类似<code>sizeof</code>，<code>sizeof…</code>也返回一个常量表达式，而且不会对其实参求值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><p>可变参数函数通常是递归的，第一步调用参数包中的第一个实参，然后用剩余实参调用自身。为了终止递归，还需要定义一个非可变参数的函数。</p>
<table>
<thead>
<tr>
<th align="center">Call</th>
<th align="center">t</th>
<th align="center">rest…</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>print(cout, i, s, 42)</code></td>
<td align="center">i</td>
<td align="center">s, 42</td>
</tr>
<tr>
<td align="center"><code>print(cout, s, 42)</code></td>
<td align="center">s</td>
<td align="center">42</td>
</tr>
<tr>
<td align="center"><code>print(cout, 42)</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>对于一个参数包，除了获取其大小外，唯一能对它做的事情就是扩展。当扩展一个包时，需要提供用于每个扩展元素的模式（pattern）。扩展一个包就是将其分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边添加一个省略号<code>…</code>来触发扩展操作。</p>
<p>包扩展工作过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... rest)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个扩展操作扩展模板参数包，为<code>print</code>生成函数参数列表。编译器将模式<code>const Args&amp;</code>应用到模板参数包<code>Args</code>中的每个元素上。因此该模式的扩展结果是一个以逗号分隔的零个或多个类型的列表，每个类型都形如<code>const type&amp;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(cout, i, s, <span class="number">42</span>);   </span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> string&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个扩展操作扩展函数参数包，模式是函数参数包的名字。扩展结果是一个由包中元素组成、以逗号分隔的列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(os, s, <span class="number">42</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>扩展操作中的模式会独立地应用于包中的每个元素。</p>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><p>在C++11中，可以组合使用可变参数模板和<code>forward</code>机制来编写函数，实现将其实参不变地传递给其他函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Args&amp;&amp;... args)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">work</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><p>在某些情况下，通用模板的定义对特定类型是不合适的，可能编译失败或者操作不正确。如果不希望或不能使用模板版本时，可以定义类或函数模板的特例化版本。一个特例化版本就是模板的一个独立定义，其中的一个或多个模板参数被指定为特定类型。</p>
<p>特例化一个函数模板时，必须为模板中的每个模板参数都提供实参。为了指明我们正在实例化一个模板，应该在关键字<code>template</code>后面添加一个空尖括号对<code>&lt;&gt;</code>。</p>
<p>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。</p>
<p>定义特例化函数版本本质上是接管编译器的工作，为模板的一个特殊实例提供了定义。特例化并非重载，因此不影响函数匹配。</p>
<p>将一个特殊版本的函数定义为特例化模板还是独立的非模板函数会影响到重载函数匹配。</p>
<p>模板特例化遵循普通作用域规则。为了特例化一个模板，原模板的声明必须在作用域中。而使用模板实例时，也必须先包含特例化版本的声明。</p>
<p>通常，模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明放在文件开头，后面是这些模板的特例化版本。</p>
<p>类模板也可以特例化。与函数模板不同，类模板的特例化不必为所有模板参数提供实参，可以只指定一部分模板参数。一个类模板的部分特例化（partial specialization）版本本身还是一个模板，用户使用时必须为那些未指定的模板参数提供实参。</p>
<p>只能部分特例化类模板，不能部分特例化函数模板。</p>
<p>由于类模板的部分特例化版本是一个模板，所以需要定义模板参数。对于每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，需要为特例化的模板参数指定实参，这些实参位于模板名之后的尖括号中，与原始模板中的参数按位置相对应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特例化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T &amp;&gt;   <span class="comment">// 左值引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T &amp;&amp;&gt;  <span class="comment">// 右值引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类模板部分特例化版本的模板参数列表是原始模板参数列表的一个子集或特例化版本。</p>
<p>可以只特例化类模板的指定成员函数，而不用特例化整个模板。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/26/C++%20Primer%20Chapter%2015%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/26/C++%20Primer%20Chapter%2015%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 15 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-26 19:45:24" itemprop="dateCreated datePublished" datetime="2023-05-26T19:45:24+08:00">2023-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-27 14:58:17" itemprop="dateModified" datetime="2023-05-27T14:58:17+08:00">2023-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第15章-面向对象程序设计"><a href="#第15章-面向对象程序设计" class="headerlink" title="第15章 面向对象程序设计"></a>第15章 面向对象程序设计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>面向对象程序设计的核心思想是数据抽象（封装）、继承和动态绑定（多态）。</p>
<p>通过继承（inheritance）联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类（base class），其他类则直接或间接地从基类继承而来，这些继承得到的类叫做派生类（derived class）。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类应该将这些函数声明为虚函数（virtual function）。方法是在函数名称前添加<code>virtual</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个或哪些基类继承而来的。类派生列表的形式首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以添加访问说明符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类必须在其内部对所有重新定义的虚函数进行声明。</p>
<p>使用基类的引用或指针调用一个虚函数时将发生动态绑定（dynamic binding），也叫运行时绑定（run-time binding）。函数的运行版本将由实参决定。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
<p>除构造函数之外的任何非静态函数都能定义为虚函数。<code>virtual</code>关键字只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。</p>
<p>派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>类派生列表中的访问说明符用于控制派生类从基类继承而来的成员是否对派生类的用户可见。</p>
<p>如果派生类没有覆盖其基类的某个虚函数，则该虚函数的行为类似于其他的普通函数，派生类会直接继承其在基类中的版本。</p>
<p>C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。</p>
<p>因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。</p>
<p>每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p,</span><br><span class="line">            std::<span class="type">size_t</span> qty, <span class="type">double</span> disc) :</span><br><span class="line">    <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。</p>
<p>派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。</p>
<p>派生类可以访问基类的公有成员和受保护成员。</p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。</p>
<p>已经完整定义的类才能被用作基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/* ... */</span> &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>: <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>: <span class="keyword">public</span> D1 &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><code>Base</code>是<code>D1</code>的直接基类（direct base），是<code>D2</code>的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。</p>
<p>C++11中，在类名后面添加<code>final</code>关键字可以禁止其他类继承它。</p>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。</p>
<p>表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。</p>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<p>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</p>
<p>如果在基类中含有一个或多个虚函数，可以使用<code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用，该转换的安全检查将在运行期间执行。</p>
<p>如果已知某个基类到派生类的转换是安全的，可以使用<code>static_cast</code>强制覆盖掉编译器的检查工作。</p>
<p>派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。</p>
<p>派生类到基类的转换允许我们给基类的拷贝&#x2F;移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。</p>
<p>用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。</p>
<p>在派生类中覆盖某个虚函数时，可以再次使用<code>virtual</code>关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。</p>
<p>在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p>
<p>派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。</p>
<p>C++11允许派生类使用<code>override</code>关键字显式地注明虚函数。如果<code>override</code>标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。<code>override</code>位于函数参数列表之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;    <span class="comment">// ok</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;      <span class="comment">// error</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与禁止类继承类似，函数也可以通过添加<code>final</code>关键字来禁止覆盖操作。</p>
<p><code>final</code>和<code>override</code>关键字出现在形参列表（包括任何<code>const</code>或引用修饰符）以及尾置返回类型之后。</p>
<p>虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。</p>
<p>使用作用域运算符<code>::</code>可以强制执行虚函数的某个版本，不进行动态绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。</p>
<p>如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>在类内部虚函数声明语句的分号前添加<code>=0</code>可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</p>
<p>含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。</p>
<p>不能创建抽象基类的对象。</p>
<p>派生类构造函数只初始化它的直接基类。</p>
<p>重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>一个类可以使用<code>protected</code>关键字来声明外部代码无法访问，但是派生类对象可以访问的成员。</p>
<p>派生类的成员或友元只能通过派生类对象来访问基类的<code>protected</code>成员。派生类对于一个基类对象中的<code>protected</code>成员没有任何访问权限。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;    </span><br><span class="line">    <span class="type">int</span> j;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>基类中成员的访问说明符和派生列表中的访问说明符都会影响某个类对其继承成员的访问权限。</p>
<p>派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没有影响，对基类成员的访问权限只与基类中的访问说明符有关。</p>
<p>派生访问说明符的作用是控制派生类（包括派生类的派生类）用户对于基类成员的访问权限。</p>
<ul>
<li><p>如果使用公有继承，则基类的公有成员和受保护成员在派生类中属性不发生改变。</p>
</li>
<li><p>如果使用受保护继承，则基类的公有成员和受保护成员在派生类中变为受保护成员。</p>
</li>
<li><p>如果使用私有继承，则基类的公有成员和受保护成员在派生类中变为私有成员。</p>
</li>
</ul>
<p>派生类到基类转换的可访问性（假定<code>D</code>继承自<code>B</code>）：</p>
<ul>
<li><p>只有当<code>D</code>公有地继承<code>B</code>时，用户代码才能使用派生类到基类的转换。</p>
</li>
<li><p>不论<code>D</code>以什么方式继承<code>B</code>，<code>D</code>的成员函数和友元都能使用派生类到基类的转换。</p>
</li>
<li><p>如果<code>D</code>继承<code>B</code>的方式是公有的或者受保护的，则<code>D</code>的派生类的成员函数和友元可以使用<code>D</code>到<code>B</code>的类型转换；反之，如果<code>D</code>继承<code>B</code>的方式是私有的，则不能使用。</p>
</li>
</ul>
<p>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类到基类的类型转换也是可访问的。</p>
<p>友元对基类的访问权限由基类自身控制，即使对于派生类中的基类部分也是如此。</p>
<p>友元关系不能继承，每个类负责控制各自成员的访问权限。</p>
<p>使用<code>using</code>声明可以改变派生类继承的某个名字的访问级别。新的访问级别由该<code>using</code>声明之前的访问说明符决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类只能为那些它可以访问的名字提供<code>using</code>声明。</p>
<p>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的，而使用<code>struct</code>关键字定义的派生类是公有继承的。</p>
<p>建议显式地声明派生类的继承方式，不要仅仅依赖于默认设置。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。</p>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。</p>
<p>派生类定义的成员会隐藏同名的基类成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mem; &#125;   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> mem;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以通过作用域运算符<code>::</code>来使用被隐藏的基类成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
<p>和其他函数一样，成员函数无论是否是虚函数都能被重载。</p>
<p>派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对它来说都是可见的，那么它就需要覆盖所有版本，或者一个也不覆盖。</p>
<p>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时如果我们不得不覆盖基类中的每一个版本的话，操作会极其繁琐。为了简化操作，可以为重载成员提供<code>using</code>声明。<code>using</code>声明指定了一个函数名字但不指定形参列表，所以一条基类成员函数的<code>using</code>声明语句就可以把该函数的所有重载实例添加到派生类作用域中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fm3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fm3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 让Base内名为mf1和mf3的所有定义</span></span><br><span class="line">    <span class="comment">// 在Derived作用域内可见</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf1;</span><br><span class="line">    <span class="keyword">using</span> Base::mf3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fm3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fm4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类内使用<code>using</code>声明改变访问级别的规则同样适用于重载函数的名字。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作。但基类的析构函数不遵循该规则。</p>
<p>基类通常应该定义一个虚析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针会产生未定义的结果。</p>
<p>虚析构函数会阻止编译器为类合成移动操作。</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类直接基类的成员。</p>
<p>派生类中删除的拷贝控制与基类的关系：</p>
<ul>
<li><p>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的函数，则派生类中对应的成员也会是被删除的。因为编译器不能使用基类成员来执行派生类对象中基类部分的构造、赋值或销毁操作。</p>
</li>
<li><p>如果基类的析构函数是被删除的或者不可访问的，则派生类中合成的默认和拷贝构造函数也会是被删除的。因为编译器无法销毁派生类对象中的基类部分。</p>
</li>
<li><p>编译器不会合成一个被删除的移动操作。当我们使用<code>=default</code>请求一个移动操作时，如果基类中对应的操作是被删除的或者不可访问的，则派生类中的操作也会是被删除的。因为派生类对象中的基类部分不能移动。同样，如果基类的析构函数是被删除的或者不可访问的，则派生类的移动构造函数也会是被删除的。</p>
</li>
</ul>
<p>在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。</p>
<p>因为基类缺少移动操作会阻止编译器为派生类合成自己的移动操作，所以当我们确实需要执行移动操作时，应该首先在基类中进行定义。</p>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类成员在内的整个对象。</p>
<p>当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分。</p>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果想拷贝或移动基类部分，则必须在派生类的构造函数初始化列表中显式地使用基类的拷贝或移动构造函数。</p>
<p>派生类的赋值运算符必须显式地为其基类部分赋值。</p>
<p>派生类的析构函数只负责销毁派生类自己分配的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">D</span>() &#123;  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>C++11新标准允许派生类重用（非常规方式继承）其直接基类定义的构造函数。继承方式是提供一条注明了直接基类名的<code>using</code>声明语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Disc_quote</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote;  </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>using</code>声明语句只是令某个名字在当前作用域内可见。而作用于构造函数时，<code>using</code>声明将令编译器产生代码。对于基类的每个构造函数，编译器都会生成一个与其形参列表完全相同的派生类构造函数。如果派生类含有自己的数据成员，则这些成员会被默认初始化。</p>
<p>构造函数的<code>using</code>声明不会改变该函数的访问级别，不能指定<code>explicit</code>或<code>constexpr</code>属性。</p>
<p>定义在派生类中的构造函数会替换继承而来的具有相同形参列表的构造函数。</p>
<p>派生类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器会为其合成它们。</p>
<p>当一个基类构造函数含有默认实参时，这些默认值不会被继承。相反，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认值的形参。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>因为容器中不能保存不同类型的元素，所以不能把具有继承关系的多种类型的对象直接存储在容器中。</p>
<p>容器不能和存在继承关系的类型兼容。</p>
<p>如果想在容器中存储具有继承关系的对象，则应该存放基类的指针。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/20/C++%20Primer%20Chapter%2014%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/20/C++%20Primer%20Chapter%2014%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 14 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-20 14:46:56" itemprop="dateCreated datePublished" datetime="2023-05-20T14:46:56+08:00">2023-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-27 14:51:57" itemprop="dateModified" datetime="2023-05-27T14:51:57+08:00">2023-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第14章-重载运算与类型转换"><a href="#第14章-重载运算与类型转换" class="headerlink" title="第14章 重载运算与类型转换"></a>第14章 重载运算与类型转换</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>重载的运算符是具有特殊名字的函数，重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参。</p>
<p>如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的<code>this</code>指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。</p>
<p>当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。</p>
<p>只能重载大多数已有的运算符，无权声明新的运算符号。</p>
<p>重载运算符的优先级和结合律与对应的内置运算符一致。</p>
<p>可以像调用普通函数一样直接调用运算符函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;            </span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);    </span><br><span class="line">data1 += data2;           </span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);  </span><br></pre></td></tr></table></figure>

<p>通常情况下，不应该重载逗号<code>,</code>、取地址<code>&amp;</code>、逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>运算符。</p>
<p>建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。</p>
<p>如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。</p>
<p>把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;     <span class="comment">// ok</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s;  </span><br></pre></td></tr></table></figure>

<p>如何选择将运算符定义为成员函数还是普通函数：</p>
<ul>
<li><p>赋值<code>=</code>、下标<code>[]</code>、调用<code>()</code>和成员访问箭头<code>-&gt;</code>运算符必须是成员函数。</p>
</li>
<li><p>复合赋值运算符一般是成员函数，但并非必须。</p>
</li>
<li><p>改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。</p>
</li>
<li><p>具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。</p>
</li>
</ul>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符<code>&lt;&lt;</code></h3><p>通常情况下，输出运算符的第一个形参是<code>ostream</code>类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的<code>ostream</code>形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出运算符应该尽量减少格式化操作。</p>
<p>输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符<code>&gt;&gt;</code></h3><p>通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。</p>
<p>输入运算符必须处理输入失败的情况，而输出运算符不需要。</p>
<p>以下情况可能导致读取操作失败：</p>
<ul>
<li><p>读取了错误类型的数据。</p>
</li>
<li><p>读取操作到达文件末尾。</p>
</li>
<li><p>遇到输入流的其他错误。</p>
</li>
</ul>
<p>当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。</p>
<p>如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置<code>failbit</code>状态。<code>eofbit</code>、<code>badbit</code>等错误最好由IO标准库自己标示。</p>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。</p>
<p>算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的<code>const</code>类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = lhs;   </span><br><span class="line">    sum += rhs;     </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类定义了算术运算符，则通常也会定义对应的复合赋值运算符，此时最有效的方式是使用复合赋值来实现算术运算符。</p>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>相等运算符设计准则：</p>
<ul>
<li><p>如果类在逻辑上有相等性的含义，则应该定义<code>operator==</code>而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。</p>
</li>
<li><p>通常情况下，<code>operator==</code>应该具有传递性。</p>
</li>
<li><p>如果类定义了<code>operator==</code>，则也应该定义<code>operator!=</code>。</p>
</li>
<li><p><code>operator==</code>和<code>operator!=</code>中的一个应该把具体工作委托给另一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>() &amp;&amp;</span><br><span class="line">        lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">        lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义<code>operator&lt;</code>会比较实用。</p>
<p>关系运算符设计准则：</p>
<ul>
<li><p>定义顺序关系，令其与关联容器中对关键字的要求保持一致。</p>
</li>
<li><p>如果类定义了<code>operator==</code>，则关系运算符的定义应该与<code>operator==</code>保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。</p>
</li>
<li><p>只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义<code>operator&lt;</code>。</p>
</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();     </span><br><span class="line">    elements = data.first;     </span><br><span class="line">    space</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>下标运算符必须定义为成员函数。</p>
<p>类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n)</span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">    <span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *elements; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。</p>
<p>为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    ++curr;    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后置递增或递减运算符接受一个额外的（不被使用）<code>int</code>类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++();    </span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="type">int</span>);  </span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的<code>const</code>类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;      </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。</p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>箭头运算符必须定义为成员函数，解引用运算符通常也是如此。</p>
<p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr]; </span><br><span class="line">    &#125;</span><br><span class="line">    std::string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于形如<code>point-&gt;mem</code>的表达式来说，<code>point</code>必须是指向类对象的指针或者是一个重载了<code>operator-&gt;</code>的类的对象。<code>point</code>类型不同，<code>point-&gt;mem</code>的含义也不同。</p>
<ul>
<li><p>如果<code>point</code>是指针，则调用内置箭头运算符，表达式等价于<code>(*point).mem</code>。</p>
</li>
<li><p>如果<code>point</code>是重载了<code>operator-&gt;</code>的类的对象，则使用<code>point.operator-&gt;()</code>的结果来获取<code>mem</code>，表达式等价于<code>(point.operator-&gt;())-&gt;mem</code>。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。</p>
</li>
</ul>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream &amp;o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">        <span class="built_in">os</span>(o), <span class="built_in">sep</span>(c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os; </span><br><span class="line">    <span class="type">char</span> sep;      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintString printer; </span><br><span class="line"><span class="built_in">printer</span>(s);   </span><br></pre></td></tr></table></figure>

<p>如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), <span class="built_in">PrintString</span>(cerr, <span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="lambda是函数对象（Lambdas-Are-Function-Objects）"><a href="#lambda是函数对象（Lambdas-Are-Function-Objects）" class="headerlink" title="lambda是函数对象（Lambdas Are Function Objects）"></a>lambda是函数对象（Lambdas Are Function Objects）</h3><p>编写一个<code>lambda</code>后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShorterString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>lambda</code>默认不能改变它捕获的变量。因此在默认情况下，由<code>lambda</code>产生的类中的函数调用运算符是一个<code>const</code>成员函数。如果<code>lambda</code>被声明为可变的，则调用运算符就不再是<code>const</code>函数了。</p>
<p><code>lambda</code>通过引用捕获变量时，由程序负责确保<code>lambda</code>执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在<code>lambda</code>产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到<code>lambda</code>中，此时<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [sz](<span class="type">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizeComp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SizeComp</span>(<span class="type">size_t</span> n): <span class="built_in">sz</span>(n) &#123; &#125;   </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> sz;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>lambda</code>产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝&#x2F;移动构造函数则通常要视捕获的变量类型而定。</p>
<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>标准库在头文件<code>functional</code>中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。</p>
<p>关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string *&gt; nameTable;   </span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(),</span><br><span class="line">        [](string *a, string *b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;string*&gt;());</span><br></pre></td></tr></table></figure>

<h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与<code>function</code></h3><p>调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</p>
<p>标准库<code>function</code>类型是一个模板，定义在头文件<code>functional</code>中，用来表示对象的调用形式。</p>
<p>创建一个具体的<code>function</code>类型时必须提供其所表示的对象的调用形式。</p>
<p>不能直接将重载函数的名字存入<code>function</code>类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用<code>lambda</code>或者存储函数指针而非函数名字。</p>
<p>C++11新标准库中的<code>function</code>类与旧版本中的<code>unary_function</code>和<code>binary_function</code>没有关系，后两个类已经被<code>bind</code>函数代替。</p>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换。</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>类型转换运算符可以面向除了<code>void</code>以外的任意类型（该类型要能作为函数的返回类型）进行定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。</p>
<p>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p>
<p>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。</p>
<p>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。</p>
<ul>
<li><p><code>if</code>、<code>while</code>、<code>do-while</code>语句的条件部分。</p>
</li>
<li><p><code>for</code>语句头的条件表达式。</p>
</li>
<li><p>条件运算符<code>? :</code>的条件表达式。</p>
</li>
<li><p>逻辑非运算符<code>!</code>、逻辑或运算符<code>||</code>、逻辑与运算符<code>&amp;&amp;</code>的运算对象。</p>
</li>
</ul>
<p>类类型向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般被定义为显式的。</p>
<h3 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h3><p>在两种情况下可能产生多重转换路径：</p>
<ul>
<li><p><code>A</code>类定义了一个接受<code>B</code>类对象的转换构造函数，同时<code>B</code>类定义了一个转换目标是<code>A</code>类的类型转换运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B&amp;); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</p>
</li>
</ul>
<p>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());    <span class="comment">// ok</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。</p>
<p>使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。</p>
<p>如果在调用重载函数时需要使用构造函数或者强制类型转换来改变实参的类型，通常意味着程序设计存在不足。</p>
<p>调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">E</span>(<span class="type">double</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> E&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip2</span>(<span class="number">10</span>);    </span><br></pre></td></tr></table></figure>

<h3 id="函数匹配与重载运算符"><a href="#函数匹配与重载运算符" class="headerlink" title="函数匹配与重载运算符"></a>函数匹配与重载运算符</h3><p>表达式中运算符的候选函数集既包括成员函数，也包括非成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="type">const</span> SmallInt&amp;, <span class="type">const</span> SmallInt&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> = <span class="number">0</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line">SmallInt s3 = s1 + s2;   </span><br><span class="line"><span class="type">int</span> i = s3 + <span class="number">0</span>;    <span class="comment">// error: ambiguous</span></span><br></pre></td></tr></table></figure>

<p>如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/19/C++%20Primer%20Chapter%2013%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/19/C++%20Primer%20Chapter%2013%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 13 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-19 17:21:56" itemprop="dateCreated datePublished" datetime="2023-05-19T17:21:56+08:00">2023-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-27 14:45:52" itemprop="dateModified" datetime="2023-05-27T14:45:52+08:00">2023-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第13章-拷贝控制"><a href="#第13章-拷贝控制" class="headerlink" title="第13章 拷贝控制"></a>第13章 拷贝控制</h1><p>一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁操作。</p>
<p>拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数</p>
<p>这些操作统称为拷贝控制操作</p>
<p>在定义任何类时，拷贝控制操作都是必要部分。</p>
<h2 id="拷贝、赋值、销毁"><a href="#拷贝、赋值、销毁" class="headerlink" title="拷贝、赋值、销毁"></a>拷贝、赋值、销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用（几乎总是<code>const</code>引用），且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>();   </span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于拷贝构造函数在一些情况下会被隐式使用，因此通常不会声明为<code>explicit</code>的。</p>
<p>如果类未定义自己的拷贝构造函数，编译器会为类合成一个。一般情况下，合成拷贝构造函数（synthesized copy constructor）会将其参数的非<code>static</code>成员逐个拷贝到正在创建的对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data &amp;orig):</span><br><span class="line">    <span class="built_in">bookNo</span>(orig.bookNo),</span><br><span class="line">    <span class="built_in">units_sold</span>(orig.units_sold),    </span><br><span class="line">    <span class="built_in">revenue</span>(orig.revenue)  </span><br><span class="line">    &#123; &#125; </span><br></pre></td></tr></table></figure>

<p>使用直接初始化时，实际上是要求编译器按照函数匹配规则来选择与实参最匹配的构造函数。使用拷贝初始化时，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;.&#x27;</span>)</span></span>;  </span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(dots)</span></span>;         </span><br><span class="line">string s2 = dots;     </span><br></pre></td></tr></table></figure>

<p>拷贝初始化通常使用拷贝构造函数来完成。但如果一个类拥有移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。</p>
<p>发生拷贝初始化的情况：</p>
<ul>
<li><p>用<code>=</code>定义变量。</p>
</li>
<li><p>将对象作为实参传递给非引用类型的形参。</p>
</li>
<li><p>从返回类型为非引用类型的函数返回对象。</p>
</li>
<li><p>用花括号列表初始化数组中的元素或聚合类中的成员。</p>
</li>
</ul>
<p>当传递一个实参或者从函数返回一个值时，不能隐式使用<code>explicit</code>构造函数。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>重载运算符（overloaded operator）的参数表示运算符的运算对象。</p>
<p>如果一个运算符是成员函数，则其左侧运算对象会绑定到隐式的<code>this</code>参数上。</p>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</p>
<p>如果类未定义自己的拷贝赋值运算符，编译器会为类合成一个。一般情况下，合成拷贝赋值运算符（synthesized copy-assignment operator）会将其右侧运算对象的非<code>static</code>成员逐个赋值给左侧运算对象的对应成员，之后返回左侧运算对象的引用。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数负责释放对象使用的资源，并销毁对象的非<code>static</code>数据成员。</p>
<p>析构函数的名字由波浪号<code>~</code>接类名构成，它没有返回值，也不接受参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Foo</span>(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于析构函数不接受参数，所以它不能被重载。</p>
<p>如果类未定义自己的析构函数，编译器会为类合成一个。合成析构函数（synthesized destructor）的函数体为空。</p>
<p>析构函数首先执行函数体，然后再销毁数据成员。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。成员按照初始化顺序的逆序销毁。</p>
<p>隐式销毁一个内置指针类型的成员不会<code>delete</code>它所指向的对象。</p>
<p>无论何时一个对象被销毁，都会自动调用其析构函数。</p>
<p>当指向一个对象的引用或指针离开作用域时，该对象的析构函数不会执行。</p>
<h3 id="三-x2F-五法则"><a href="#三-x2F-五法则" class="headerlink" title="三&#x2F;五法则"></a>三&#x2F;五法则</h3><p>需要析构函数的类一般也需要拷贝和赋值操作。</p>
<p>需要拷贝操作的类一般也需要赋值操作，反之亦然。</p>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用<code>=default</code></h3><p>可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类内使用<code>=default</code>修饰成员声明时，合成的函数是隐式内联的。如果不希望合成的是内联函数，应该只对成员的类外定义使用<code>=default</code>。</p>
<p>只能对具有合成版本的成员函数使用<code>=default</code>。</p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是显式地还是隐式地。</p>
<p>在C++11新标准中，将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）可以阻止类对象的拷贝。删除的函数是一种虽然进行了声明，但是却不能以任何方式使用的函数。定义删除函数的方式是在函数的形参列表后面添加<code>=delete</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; </span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>=delete</code>和<code>=default</code>有两点不同：</p>
<ul>
<li><p><code>=delete</code>可以对任何函数使用；<code>=default</code>只能对具有合成版本的函数使用。</p>
</li>
<li><p><code>=delete</code>必须出现在函数第一次声明的地方；<code>=default</code>既能出现在类内，也能出现在类外。</p>
</li>
</ul>
<p>析构函数不能是删除的函数。对于析构函数被删除的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。</p>
<p>如果一个类中有数据成员不能默认构造、拷贝或销毁，则对应的合成拷贝控制成员将被定义为删除的。</p>
<p>在旧版本的C++标准中，类通过将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>成员来阻止类对象的拷贝。在新标准中建议使用<code>=delete</code>而非<code>private</code>。</p>
<h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><p>通常，管理类外资源的类必须定义拷贝控制成员。</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr &amp;p):</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*p.ps)), <span class="built_in">i</span>(p.i) &#123; &#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;);</span><br><span class="line">    ~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编写赋值运算符时有两点需要注意：</p>
<ul>
<li><p>即使将一个对象赋予它自身，赋值运算符也能正确工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG way</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;  </span><br><span class="line">    ps = <span class="keyword">new</span> <span class="built_in">string</span>(*(rhs.ps));</span><br><span class="line">    i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值运算符通常结合了拷贝构造函数和析构函数的工作。</p>
<p>编写赋值运算符时，一个好的方法是先将右侧运算对象拷贝到一个局部临时对象中。拷贝完成后，就可以安全地销毁左侧运算对象的现有成员了。</p>
</li>
</ul>
<h3 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">use</span>(<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr &amp;p):</span><br><span class="line">        <span class="built_in">ps</span>(p.ps), <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123; ++*use; &#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp;);</span><br><span class="line">    ~<span class="built_in">HasPtr</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::<span class="type">size_t</span> *use; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>析构函数释放内存前应该判断是否还有其他对象指向这块内存。</p>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>通常，管理类外资源的类会定义<code>swap</code>函数。如果一个类定义了自己的<code>swap</code>函数，算法将使用自定义版本，否则将使用标准库定义的<code>swap</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.ps, rhs.ps);  </span><br><span class="line">    <span class="built_in">swap</span>(lhs.i, rhs.i);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些算法在交换两个元素时会调用<code>swap</code>函数，其中每个<code>swap</code>调用都应该是未加限定的。如果存在类型特定的<code>swap</code>版本，其匹配程度会优于<code>std</code>中定义的版本（假定作用域中有<code>using</code>声明）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    std::<span class="built_in">swap</span>(lhs.h, rhs.h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.h, rhs.h); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与拷贝控制成员不同，<code>swap</code>函数并不是必要的。但是对于分配了资源的类，定义<code>swap</code>可能是一种重要的优化手段。</p>
<p>由于<code>swap</code>函数的存在就是为了优化代码，所以一般将其声明为内联函数。</p>
<p>定义了<code>swap</code>的类通常用<code>swap</code>来实现赋值运算符。在这种版本的赋值运算符中，右侧运算对象以值方式传递，然后将左侧运算对象与右侧运算对象的副本进行交换（拷贝并交换，copy and swap）。这种方式可以正确处理自赋值情况。</p>
<h2 id="拷贝控制示例"><a href="#拷贝控制示例" class="headerlink" title="拷贝控制示例"></a>拷贝控制示例</h2><p>拷贝赋值运算符通常结合了拷贝构造函数和析构函数的工作。在这种情况下，公共部分应该放在<code>private</code>的工具函数中完成。</p>
<h2 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h2><p>移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象中。</p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>某些情况下，一个对象拷贝后就立即被销毁了，此时移动而非拷贝对象会大幅度提高性能。</p>
<p>在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。</p>
<p>标准库容器、<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝。IO类和<code>unique_ptr</code>类可以移动但不能拷贝。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作，C++11引入了右值引用类型。右值引用就是必须绑定到右值的引用。可以通过<code>&amp;&amp;</code>来获得右值引用。</p>
<p>右值引用只能绑定到即将被销毁，并且没有其他用户的临时对象上。使用右值引用的代码可以自由地接管所引用对象的资源。</p>
<p>变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;     </span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1;    </span><br></pre></td></tr></table></figure>

<p>调用<code>move</code>函数可以获得绑定在左值上的右值引用，此函数定义在头文件<code>utility</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure>

<p>调用<code>move</code>函数的代码应该使用<code>std::move</code>而非<code>move</code>，这样做可以避免潜在的名字冲突。</p>
<h3 id="移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）"><a href="#移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）" class="headerlink" title="移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）"></a>移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）</h3><p>移动构造函数的第一个参数是该类类型的右值引用，其他任何额外参数都必须有默认值。</p>
<p>除了完成资源移动，移动构造函数还必须确保移后源对象是可以安全销毁的。</p>
<p>在函数的形参列表后面添加关键字<code>noexcept</code>可以指明该函数不会抛出任何异常。</p>
<p>对于构造函数，<code>noexcept</code>位于形参列表和初始化列表开头的冒号之间。在类的头文件声明和定义中（如果定义在类外）都应该指定<code>noexcept</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>(StrVec&amp;&amp;) <span class="keyword">noexcept</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>标准库容器能对异常发生时其自身的行为提供保障。虽然移动操作通常不抛出异常，但抛出异常也是允许的。为了安全起见，除非容器确定元素类型的移动操作不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝而非移动操作。</p>
<p>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</p>
<p>在移动操作之后，移后源对象必须保持有效的、可销毁的状态，但是用户不能使用它的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();     </span><br><span class="line">        elements = rhs.elements;    </span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当一个类没有定义任何拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为类合成移动构造函数和移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，则编译器也能移动该成员。</p>
<p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p>
<p>定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认地定义为删除的函数。</p>
<p>如果一个类有可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的，即使调用<code>move</code>函数时也是如此。拷贝赋值运算符和移动赋值运算符的情况类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>;   </span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(std::move(x))</span></span>;   </span><br></pre></td></tr></table></figure>

<p>使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能。依赖于实参的类型，左值被拷贝，右值被移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hp = hp2;  </span><br><span class="line">hp = std::<span class="built_in">move</span>(hp2);   </span><br></pre></td></tr></table></figure>

<p>建议将五个拷贝控制成员当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。</p>
<p>移动赋值运算符可以直接检查自赋值情况。</p>
<p>C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。</p>
<p>调用<code>make_move_iterator</code>函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。</p>
<p>最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用<code>move</code>操作。</p>
<h3 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h3><p>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>参数，另一个版本接受一个<code>T&amp;&amp;</code>参数（<code>T</code>为类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>;   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;      </span><br></pre></td></tr></table></figure>

<p>有时可以对右值赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">s1 + s2 = <span class="string">&quot;wow!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即<code>this</code>指向的对象）必须是一个左值。</p>
<p>在非<code>static</code>成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定<code>this</code>的左值&#x2F;右值属性。引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别表示<code>this</code>可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) &amp;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;rhs) &amp;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非<code>static</code>成员函数可以同时使用<code>const</code>和引用限定符，此时引用限定符跟在<code>const</code>限定符之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="type">const</span></span>;     </span><br><span class="line">    <span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;   <span class="comment">// ok</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>引用限定符也可以区分成员函数的重载版本。</p>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">using</span> Comp = <span class="built_in">bool</span>(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;);</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span></span>;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/04/C++%20Primer%20Chapter%2012%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/04/C++%20Primer%20Chapter%2012%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 12 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-04 20:12:11" itemprop="dateCreated datePublished" datetime="2023-04-04T20:12:11+08:00">2023-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-20 17:57:33" itemprop="dateModified" datetime="2023-05-20T17:57:33+08:00">2023-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第12章-动态内存"><a href="#第12章-动态内存" class="headerlink" title="第12章 动态内存"></a>第12章 动态内存</h1><p>程序用堆（heap）来存储动态分配的对象。动态对象的生存期由程序控制。</p>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</p>
<p>新标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：<code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>独占所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在头文件<code>memory</code>中。</p>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a><code>shared_ptr</code>类</h3><p>智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;      </span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2;   </span><br></pre></td></tr></table></figure>

<p><code>make_shared</code>函数（定义在头文件<code>memory</code>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>进行拷贝或赋值操作时，每个<code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>与其指向相同的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;  </span><br></pre></td></tr></table></figure>

<p>每个<code>shared_ptr</code>都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝<code>shared_ptr</code>时引用计数会递增。例如使用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>，或将它作为参数传递给函数以及作为函数的返回值返回。给<code>shared_ptr</code>赋予新值或<code>shared_ptr</code>被销毁时引用计数会递减。例如一个局部<code>shared_ptr</code>离开其作用域。一旦一个<code>shared_ptr</code>的引用计数变为0，它就会自动释放其所管理的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  </span><br><span class="line">r = q;  </span><br></pre></td></tr></table></figure>

<p><code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数。如果引用计数变为0，<code>shared_ptr</code>的析构函数会销毁对象并释放空间。</p>
<p>如果将<code>shared_ptr</code>存放于容器中，而后不再需要全部元素，而只使用其中一部分，应该用<code>erase</code>删除不再需要的元素。</p>
<p>程序使用动态内存通常出于以下三种原因之一：</p>
<ul>
<li><p>不确定需要使用多少对象。</p>
</li>
<li><p>不确定所需对象的准确类型。</p>
</li>
<li><p>需要在多个对象间共享数据。</p>
</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>相对于智能指针，使用<code>new</code>和<code>delete</code>管理内存很容易出错。</p>
<p>默认情况下，动态分配的对象是默认初始化的。所以内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string;    </span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>;    </span><br></pre></td></tr></table></figure>

<p>可以使用值初始化方式、直接初始化方式、传统构造方式（圆括号<code>()</code>）或新标准下的列表初始化方式（花括号<code>&#123;&#125;</code>）初始化动态分配的对象。</p>
<p>只有当初始化的括号中仅有单一初始化器时才可以使用<code>auto</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in">auto</span>(obj);   </span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125;;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>new</code>分配<code>const</code>对象，返回指向<code>const</code>类型的指针。动态分配的<code>const</code>对象必须初始化。</p>
<p>默认情况下，如果<code>new</code>不能分配所要求的内存空间，会抛出<code>bad_alloc</code>异常。使用定位<code>new</code>（placement new）可以阻止其抛出异常。定位<code>new</code>表达式允许程序向<code>new</code>传递额外参数。如果将<code>nothrow</code>传递给<code>new</code>，则<code>new</code>在分配失败后会返回空指针。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;           </span><br><span class="line"><span class="type">int</span> *p2 = <span class="built_in">new</span> (nothrow) <span class="type">int</span>; </span><br></pre></td></tr></table></figure>

<p>使用<code>delete</code>释放一块并非<code>new</code>分配的内存，或者将相同的指针值释放多次的行为是未定义的。</p>
<p>由内置指针管理的动态对象在被显式释放前一直存在。</p>
<p><code>delete</code>一个指针后，指针值就无效了（空悬指针，dangling pointer）。为了防止后续的错误访问，应该在<code>delete</code>之后将指针值置空。</p>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a><code>shared_ptr</code>和<code>new</code>结合使用</h3><p>可以用<code>new</code>返回的指针初始化智能指针。该构造函数是<code>explicit</code>的，因此必须使用直接初始化形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">// error</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替<code>delete</code>。</p>
<p>不要混合使用内置指针和智能指针。当将<code>shared_ptr</code>绑定到内置指针后，资源管理就应该交由<code>shared_ptr</code>负责。不应该再使用内置指针访问<code>shared_ptr</code>指向的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;  </span><br><span class="line"><span class="built_in">process</span>(x);     <span class="comment">// error</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));   </span><br><span class="line"><span class="type">int</span> j = *x;    </span><br></pre></td></tr></table></figure>

<p>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用<code>get</code>返回指针的代码不能<code>delete</code>此指针。</p>
<p>不要使用<code>get</code>初始化另一个智能指针或为智能指针赋值。</p>
<p>可以用<code>reset</code>函数将新的指针赋予<code>shared_ptr</code>。与赋值类似，<code>reset</code>会更新引用计数，如果需要的话，还会释放内存空间。<code>reset</code>经常与<code>unique</code>一起使用，来控制多个<code>shared_ptr</code>共享的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));   </span><br><span class="line">*p += newVal;   </span><br></pre></td></tr></table></figure>

<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *ip = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);    </span><br><span class="line">    <span class="keyword">delete</span> ip;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>默认情况下<code>shared_ptr</code>假定其指向动态内存，使用<code>delete</code>释放对象。创建<code>shared_ptr</code>时可以传递一个（可选）指向删除函数的指针参数，用来代替<code>delete</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>;   </span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>;   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* other  */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>智能指针规范：</p>
<ul>
<li><p>不使用相同的内置指针值初始化或<code>reset</code>多个智能指针。</p>
</li>
<li><p>不释放<code>get</code>返回的指针。</p>
</li>
<li><p>不使用<code>get</code>初始化或<code>reset</code>另一个智能指针。</p>
</li>
<li><p>使用<code>get</code>返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</p>
</li>
<li><p>使用<code>shared_ptr</code>管理并非<code>new</code>分配的资源时，应该传递删除函数。</p>
</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h3><p>与<code>shared_ptr</code>不同，同一时刻只能有一个<code>unique_ptr</code>指向给定的对象。当<code>unique_ptr</code>被销毁时，它指向的对象也会被销毁。</p>
<p><code>make_unique</code>函数（C++14新增，定义在头文件<code>memory</code>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>unique_ptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p2 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>由于<code>unique_ptr</code>独占其指向的对象，因此<code>unique_ptr</code>不支持普通的拷贝或赋值操作。</p>
<p><code>release</code>函数返回<code>unique_ptr</code>当前保存的指针并将其置为空。</p>
<p><code>reset</code>函数成员接受一个可选的指针参数，重新设置<code>unique_ptr</code>保存的指针。如果<code>unique_ptr</code>不为空，则它原来指向的对象会被释放。</p>
<p>调用<code>release</code>会切断<code>unique_ptr</code>和它原来管理的对象之间的联系。<code>release</code>返回的指针通常被用来初始化另一个智能指针或给智能指针赋值。如果没有用另一个智能指针保存<code>release</code>返回的指针，程序就要负责资源的释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2.<span class="built_in">release</span>();   </span><br><span class="line"><span class="keyword">auto</span> p = p2.<span class="built_in">release</span>();   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>不能拷贝<code>unique_ptr</code>的规则有一个例外：可以拷贝或赋值一个即将被销毁的<code>unique_ptr</code>（移动构造、移动赋值）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span> (p))</span></span>;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老版本的标准库包含了一个名为<code>auto_ptr</code>的类，</p>
<p>类似<code>shared_ptr</code>，默认情况下<code>unique_ptr</code>用<code>delete</code>释放其指向的对象。<code>unique_ptr</code>的删除器同样可以重载，但<code>unique_ptr</code>管理删除器的方式与<code>shared_ptr</code>不同。定义<code>unique_ptr</code>时必须在尖括号中提供删除器类型。创建或<code>reset</code>这种<code>unique_ptr</code>类型的对象时，必须提供一个指定类型的可调用对象（删除器）。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><code>weak_ptr</code></h3><p><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针，它指向一个由<code>shared_ptr</code>管理的对象。将<code>weak_ptr</code>绑定到<code>shared_ptr</code>不会改变<code>shared_ptr</code>的引用计数。如果<code>shared_ptr</code>被销毁，即使有<code>weak_ptr</code>指向对象，对象仍然有可能被释放。</p>
<p>创建一个<code>weak_ptr</code>时，需要使用<code>shared_ptr</code>来初始化它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;   </span><br></pre></td></tr></table></figure>

<p>使用<code>weak_ptr</code>访问对象时，必须先调用<code>lock</code>函数。该函数检查<code>weak_ptr</code>指向的对象是否仍然存在。如果存在，则返回指向共享对象的<code>shared_ptr</code>，否则返回空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="type">int</span>&gt; np = wp.<span class="built_in">lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>使用<code>allocator</code>类可以将内存分配和初始化过程分离，这通常会提供更好的性能和更灵活的内存管理能力。</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a><code>new</code>和数组</h3><p>使用<code>new</code>分配对象数组时需要在类型名之后跟一对方括号，在其中指明要分配的对象数量（必须是整型，但不必是常量）。<code>new</code>返回指向第一个对象的指针（元素类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">get_size</span>()];   </span><br></pre></td></tr></table></figure>

<p>由于<code>new</code>分配的内存并不是数组类型，因此不能对动态数组调用<code>begin</code>和<code>end</code>，也不能用范围<code>for</code>语句处理其中的元素。</p>
<p>默认情况下，<code>new</code>分配的对象是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小后面跟一对空括号<code>()</code>。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则<code>new</code>表达式失败，不会分配任何内存，并抛出<code>bad_array_new_length</code>异常。</p>
<p>虽然可以使用空括号对<code>new</code>分配的数组元素进行值初始化，但不能在括号中指定初始化器。这意味着不能用<code>auto</code>分配数组。</p>
<p>动态分配一个空数组是合法的，此时<code>new</code>会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。</p>
<p>使用<code>delete[]</code>释放动态数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;     </span><br><span class="line"><span class="keyword">delete</span> [] pa;   </span><br></pre></td></tr></table></figure>

<p>如果在<code>delete</code>数组指针时忘记添加方括号，或者在<code>delete</code>单一对象时使用了方括号，编译器很可能不会给出任何警告，程序可能会在执行过程中行为异常。</p>
<p><code>unique_ptr</code>可以直接管理动态数组，定义时需要在对象类型后添加一对空方括号<code>[]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   </span><br></pre></td></tr></table></figure>

<p>指向数组的<code>unique_ptr</code>。</p>
<p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不直接支持动态数组管理。如果想用<code>shared_ptr</code>管理动态数组，必须提供自定义的删除器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span> *p) &#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();   </span><br></pre></td></tr></table></figure>

<p><code>shared_ptr</code>未定义下标运算符，智能指针类型也不支持指针算术运算。因此如果想访问<code>shared_ptr</code>管理的数组元素，必须先用<code>get</code>获取内置指针，再用内置指针进行访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptrs don&#x27;t have subscript operator and don&#x27;t support pointer arithmetic</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    *(sp.<span class="built_in">get</span>() + i) = i;    </span><br></pre></td></tr></table></figure>

<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a><code>allocator</code>类</h3><p><code>allocator</code>类是一个模板，定义时必须指定其可以分配的对象类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;    </span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n);   </span><br></pre></td></tr></table></figure>

<p><code>allocator</code>分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的<code>construct</code>函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。</p>
<p>直接使用<code>allocator</code>返回的未构造内存是错误行为，其结果是未定义的。</p>
<p>对象使用完后，必须对每个构造的元素调用<code>destroy</code>进行销毁。<code>destroy</code>函数接受一个指针，对指向的对象执行析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(--q);  </span><br></pre></td></tr></table></figure>

<p><code>deallocate</code>函数用于释放<code>allocator</code>分配的内存空间。传递给<code>deallocate</code>的指针不能为空，它必须指向由<code>allocator</code>分配的内存。而且传递给<code>deallocate</code>的大小参数必须与调用<code>allocator</code>分配内存时提供的大小参数相一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.<span class="built_in">deallocate</span>(p, n);</span><br></pre></td></tr></table></figure>

<p>传递给<code>uninitialized_copy</code>的目的位置迭代器必须指向未构造的内存，它直接在给定位置构造元素。返回（递增后的）目的位置迭代器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/C++%20Primer%20Chapter%2011%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/02/C++%20Primer%20Chapter%2011%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 11 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-02 15:34:39" itemprop="dateCreated datePublished" datetime="2023-04-02T15:34:39+08:00">2023-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-20 17:57:43" itemprop="dateModified" datetime="2023-05-20T17:57:43+08:00">2023-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><p>2个主要的关联容器类型是<code>map</code>和<code>set</code>。</p>
<ul>
<li><p><code>map</code>中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。</p>
</li>
<li><p><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在<code>set</code>中。</p>
</li>
</ul>
<p>标准库提供了8个关联容器，它们之间的不同体现在三个方面：</p>
<ul>
<li><p>是<code>map</code>还是<code>set</code>类型。</p>
</li>
<li><p>是否允许保存重复的关键字。</p>
</li>
<li><p>是否按顺序保存元素。</p>
</li>
</ul>
<p>允许重复保存关键字的容器名字都包含单词<code>multi</code>；无序保存元素的容器名字都以单词<code>unordered</code>开头。</p>
<p><code>map</code>和<code>multimap</code>类型定义在头文件<code>map</code>中；<code>set</code>和<code>multiset</code>类型定义在头文件<code>set</code>中；无序容器定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中。</p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p><code>map</code>类型通常被称为关联数组（associative array）。</p>
<p>从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象。<code>pair</code>是一个模板类型，保存两个名为<code>first</code>和<code>second</code>的公有数据成员。<code>map</code>所使用的<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;  </span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    ++word_count[word];  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)  </span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second</span><br><span class="line">        &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><code>set</code>类型的<code>find</code>成员返回一个迭代器。如果给定关键字在<code>set</code>中，则迭代器指向该关键字，否则返回的是尾后迭代器。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><p>定义<code>map</code>时，必须指定关键字类型和值类型；定义<code>set</code>时，只需指定关键字类型。</p>
<p>初始化<code>map</code>时，提供的每个键值对用花括号<code>&#123;&#125;</code>包围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;   </span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span> &#125;;</span><br><span class="line">map&lt;string, string&gt; authors =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>map</code>和<code>set</code>中的关键字必须唯一，<code>multimap</code>和<code>multiset</code>没有此限制。</p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算符来进行比较操作。</p>
<p>用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a><code>pair</code>类型</h3><p><code>pair</code>定义在头文件<code>utility</code>中。一个<code>pair</code>可以保存两个数据成员，分别命名为<code>first</code>和<code>second</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        </span><br><span class="line">pair&lt;string, <span class="type">size_t</span>&gt; word_count; </span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; line;   </span><br></pre></td></tr></table></figure>

<p><code>pair</code>的默认构造函数对数据成员进行值初始化。</p>
<p>在C++11中，如果函数需要返回<code>pair</code>，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123; v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>() &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联容器操作（Operations-on-Associative-Containers）"><a href="#关联容器操作（Operations-on-Associative-Containers）" class="headerlink" title="关联容器操作（Operations on Associative Containers）"></a>关联容器操作（Operations on Associative Containers）</h2><p>关联容器定义了类型别名来表示容器关键字和值的类型。</p>
<p>对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。<code>set</code>中保存的值就是关键字。对于<code>map</code>类型，元素是关键字-值对。即每个元素是一个<code>pair</code>对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此<code>pair</code>的关键字部分是<code>const</code>的。另外，只有<code>map</code>类型（<code>unordered_map</code>、<code>unordered_multimap</code>、<code>multimap</code>、<code>map</code>）才定义了<code>mapped_type</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;        <span class="comment">// v1 is a string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;          <span class="comment">// v2 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::value_type v3;   <span class="comment">// v3 is a pair&lt;const string, int&gt;</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::key_type v4;     <span class="comment">// v4 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::mapped_type v5;  <span class="comment">// v5 is an int</span></span><br></pre></td></tr></table></figure>

<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>解引用关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的引用。对<code>map</code>而言，<code>value_type</code>是<code>pair</code>类型，其<code>first</code>成员保存<code>const</code>的关键字，<code>second</code>成员保存值。</p>
<p>虽然<code>set</code>同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器都只允许只读访问<code>set</code>中的元素。类似<code>map</code>，<code>set</code>中的关键字也是<code>const</code>的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span> (set_it != iset.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>;       <span class="comment">// error</span></span><br><span class="line">    cout &lt;&lt; *set_it &lt;&lt; endl;    <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map</code>和<code>set</code>都支持<code>begin</code>和<code>end</code>操作。使用迭代器遍历<code>map</code>、<code>multimap</code>、<code>set</code>或<code>multiset</code>时，迭代器按关键字升序遍历元素。</p>
<p>通常不对关联容器使用泛型算法。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>使用<code>insert</code>成员可以向关联容器中添加元素。向<code>map</code>和<code>set</code>中添加已存在的元素对容器没有影响。</p>
<p>通常情况下，对于想要添加到<code>map</code>中的数据，并没有现成的<code>pair</code>对象。可以直接在<code>insert</code>的参数列表中创建<code>pair</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word_count.<span class="built_in">insert</span>(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string, <span class="type">size_t</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>关联容器的<code>insert</code>操作：</p>
<p><code>insert</code>或<code>emplace</code>的返回值依赖于容器类型和参数：</p>
<ul>
<li><p>对于不包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，表示操作是否成功。<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值。如果关键字已在容器中，则<code>insert</code>直接返回，<code>bool</code>值为<code>false</code>。如果关键字不存在，元素会被添加至容器中，<code>bool</code>值为<code>true</code>。</p>
</li>
<li><p>对于允许包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回指向新元素的迭代器。</p>
</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>关联容器的删除操作：</p>
<p>与顺序容器不同，关联容器提供了一个额外的<code>erase</code>操作。它接受一个<code>key_type</code>参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，<code>erase</code>的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。</p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a><code>map</code>的下标操作</h3><p><code>map</code>下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。</p>
<p>由于下标运算符可能向容器中添加元素，所以只能对非<code>const</code>的<code>map</code>使用下标操作。</p>
<p>对<code>map</code>进行下标操作时，返回的是<code>mapped_type</code>类型的对象；解引用<code>map</code>迭代器时，返回的是<code>value_type</code>类型的对象。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>如果<code>multimap</code>或<code>multiset</code>中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。</p>
<p><code>lower_bound</code>和<code>upper_bound</code>操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，<code>lower_bound</code>返回的迭代器会指向第一个匹配给定关键字的元素，而<code>upper_bound</code>返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在<code>multimap</code>中，则<code>lower_bound</code>和<code>upper_bound</code>会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到一个迭代器范围，表示所有具有该关键字的元素范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">        end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">    cout &lt;&lt; beg-&gt;second &lt;&lt; endl;   </span><br></pre></td></tr></table></figure>

<p><code>lower_bound</code>和<code>upper_bound</code>有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则<code>upper_bound</code>返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则<code>lower_bound</code>也返回尾后迭代器。</p>
<p><code>equal_range</code>操作接受一个关键字，返回一个迭代器<code>pair</code>。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line">        pos.first != pos.second; ++pos.first)</span><br><span class="line">    cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;  </span><br></pre></td></tr></table></figure>

<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的<code>==</code>运算符组织元素。</p>
<p>无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。</p>
<p>无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。</p>
<p>默认情况下，无序容器使用关键字类型的<code>==</code>运算符比较元素，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">HUI</p>
  <div class="site-description" itemprop="description">We have a long way to go</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HUI</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

</body>
</html>
