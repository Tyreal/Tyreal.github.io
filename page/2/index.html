<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="We have a long way to go">
<meta property="og:type" content="website">
<meta property="og:title" content="HUI BLOG">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="HUI BLOG">
<meta property="og:description" content="We have a long way to go">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="HUI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HUI BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HUI BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/C++%20Primer%20Chapter%2011%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/02/C++%20Primer%20Chapter%2011%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 11 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-02 15:34:39" itemprop="dateCreated datePublished" datetime="2023-04-02T15:34:39+08:00">2023-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-20 17:57:43" itemprop="dateModified" datetime="2023-05-20T17:57:43+08:00">2023-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><p>2个主要的关联容器类型是<code>map</code>和<code>set</code>。</p>
<ul>
<li><p><code>map</code>中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。</p>
</li>
<li><p><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在<code>set</code>中。</p>
</li>
</ul>
<p>标准库提供了8个关联容器，它们之间的不同体现在三个方面：</p>
<ul>
<li><p>是<code>map</code>还是<code>set</code>类型。</p>
</li>
<li><p>是否允许保存重复的关键字。</p>
</li>
<li><p>是否按顺序保存元素。</p>
</li>
</ul>
<p>允许重复保存关键字的容器名字都包含单词<code>multi</code>；无序保存元素的容器名字都以单词<code>unordered</code>开头。</p>
<p><code>map</code>和<code>multimap</code>类型定义在头文件<code>map</code>中；<code>set</code>和<code>multiset</code>类型定义在头文件<code>set</code>中；无序容器定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中。</p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p><code>map</code>类型通常被称为关联数组（associative array）。</p>
<p>从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象。<code>pair</code>是一个模板类型，保存两个名为<code>first</code>和<code>second</code>的公有数据成员。<code>map</code>所使用的<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;  </span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    ++word_count[word];  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)  </span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second</span><br><span class="line">        &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><code>set</code>类型的<code>find</code>成员返回一个迭代器。如果给定关键字在<code>set</code>中，则迭代器指向该关键字，否则返回的是尾后迭代器。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><p>定义<code>map</code>时，必须指定关键字类型和值类型；定义<code>set</code>时，只需指定关键字类型。</p>
<p>初始化<code>map</code>时，提供的每个键值对用花括号<code>&#123;&#125;</code>包围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;   </span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span> &#125;;</span><br><span class="line">map&lt;string, string&gt; authors =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>map</code>和<code>set</code>中的关键字必须唯一，<code>multimap</code>和<code>multiset</code>没有此限制。</p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算符来进行比较操作。</p>
<p>用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a><code>pair</code>类型</h3><p><code>pair</code>定义在头文件<code>utility</code>中。一个<code>pair</code>可以保存两个数据成员，分别命名为<code>first</code>和<code>second</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        </span><br><span class="line">pair&lt;string, <span class="type">size_t</span>&gt; word_count; </span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; line;   </span><br></pre></td></tr></table></figure>

<p><code>pair</code>的默认构造函数对数据成员进行值初始化。</p>
<p>在C++11中，如果函数需要返回<code>pair</code>，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123; v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>() &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联容器操作（Operations-on-Associative-Containers）"><a href="#关联容器操作（Operations-on-Associative-Containers）" class="headerlink" title="关联容器操作（Operations on Associative Containers）"></a>关联容器操作（Operations on Associative Containers）</h2><p>关联容器定义了类型别名来表示容器关键字和值的类型。</p>
<p>对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。<code>set</code>中保存的值就是关键字。对于<code>map</code>类型，元素是关键字-值对。即每个元素是一个<code>pair</code>对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此<code>pair</code>的关键字部分是<code>const</code>的。另外，只有<code>map</code>类型（<code>unordered_map</code>、<code>unordered_multimap</code>、<code>multimap</code>、<code>map</code>）才定义了<code>mapped_type</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;        <span class="comment">// v1 is a string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;          <span class="comment">// v2 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::value_type v3;   <span class="comment">// v3 is a pair&lt;const string, int&gt;</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::key_type v4;     <span class="comment">// v4 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::mapped_type v5;  <span class="comment">// v5 is an int</span></span><br></pre></td></tr></table></figure>

<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>解引用关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的引用。对<code>map</code>而言，<code>value_type</code>是<code>pair</code>类型，其<code>first</code>成员保存<code>const</code>的关键字，<code>second</code>成员保存值。</p>
<p>虽然<code>set</code>同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器都只允许只读访问<code>set</code>中的元素。类似<code>map</code>，<code>set</code>中的关键字也是<code>const</code>的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span> (set_it != iset.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>;       <span class="comment">// error</span></span><br><span class="line">    cout &lt;&lt; *set_it &lt;&lt; endl;    <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map</code>和<code>set</code>都支持<code>begin</code>和<code>end</code>操作。使用迭代器遍历<code>map</code>、<code>multimap</code>、<code>set</code>或<code>multiset</code>时，迭代器按关键字升序遍历元素。</p>
<p>通常不对关联容器使用泛型算法。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>使用<code>insert</code>成员可以向关联容器中添加元素。向<code>map</code>和<code>set</code>中添加已存在的元素对容器没有影响。</p>
<p>通常情况下，对于想要添加到<code>map</code>中的数据，并没有现成的<code>pair</code>对象。可以直接在<code>insert</code>的参数列表中创建<code>pair</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word_count.<span class="built_in">insert</span>(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string, <span class="type">size_t</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>关联容器的<code>insert</code>操作：</p>
<p><code>insert</code>或<code>emplace</code>的返回值依赖于容器类型和参数：</p>
<ul>
<li><p>对于不包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，表示操作是否成功。<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值。如果关键字已在容器中，则<code>insert</code>直接返回，<code>bool</code>值为<code>false</code>。如果关键字不存在，元素会被添加至容器中，<code>bool</code>值为<code>true</code>。</p>
</li>
<li><p>对于允许包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回指向新元素的迭代器。</p>
</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>关联容器的删除操作：</p>
<p>与顺序容器不同，关联容器提供了一个额外的<code>erase</code>操作。它接受一个<code>key_type</code>参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，<code>erase</code>的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。</p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a><code>map</code>的下标操作</h3><p><code>map</code>下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。</p>
<p>由于下标运算符可能向容器中添加元素，所以只能对非<code>const</code>的<code>map</code>使用下标操作。</p>
<p>对<code>map</code>进行下标操作时，返回的是<code>mapped_type</code>类型的对象；解引用<code>map</code>迭代器时，返回的是<code>value_type</code>类型的对象。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>如果<code>multimap</code>或<code>multiset</code>中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。</p>
<p><code>lower_bound</code>和<code>upper_bound</code>操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，<code>lower_bound</code>返回的迭代器会指向第一个匹配给定关键字的元素，而<code>upper_bound</code>返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在<code>multimap</code>中，则<code>lower_bound</code>和<code>upper_bound</code>会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到一个迭代器范围，表示所有具有该关键字的元素范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">        end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">    cout &lt;&lt; beg-&gt;second &lt;&lt; endl;   </span><br></pre></td></tr></table></figure>

<p><code>lower_bound</code>和<code>upper_bound</code>有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则<code>upper_bound</code>返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则<code>lower_bound</code>也返回尾后迭代器。</p>
<p><code>equal_range</code>操作接受一个关键字，返回一个迭代器<code>pair</code>。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line">        pos.first != pos.second; ++pos.first)</span><br><span class="line">    cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;  </span><br></pre></td></tr></table></figure>

<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的<code>==</code>运算符组织元素。</p>
<p>无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。</p>
<p>无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。</p>
<p>默认情况下，无序容器使用关键字类型的<code>==</code>运算符比较元素，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/26/C++%20Primer%20Chapter%2010%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/26/C++%20Primer%20Chapter%2010%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 10 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-26 20:24:33" itemprop="dateCreated datePublished" datetime="2023-03-26T20:24:33+08:00">2023-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-05 20:24:32" itemprop="dateModified" datetime="2023-04-05T20:24:32+08:00">2023-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第10章-泛型算法"><a href="#第10章-泛型算法" class="headerlink" title="第10章 泛型算法"></a>第10章 泛型算法</h1><h2 id="泛型算法概述"><a href="#泛型算法概述" class="headerlink" title="泛型算法概述"></a>泛型算法概述</h2><p>大多数算法都定义在头文件<code>algorithm</code>中，此外标准库还在头文件<code>numeric</code>中定义了一组数值泛型算法。一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的元素范围进行操作。</p>
<p><code>find</code>函数将范围中的每个元素与给定值进行比较，返回指向第一个等于给定值的元素的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">42</span>;   </span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(vec.<span class="built_in">cbegin</span>(), vec.<span class="built_in">cend</span>(), val);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The value &quot;</span> &lt;&lt; val</span><br><span class="line">    &lt;&lt; (result == vec.<span class="built_in">cend</span>() ? <span class="string">&quot; is not present&quot;</span> : <span class="string">&quot; is present&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>迭代器参数令算法不依赖于特定容器，但依赖于元素类型操作。</p>
<p>泛型算法本身不会执行容器操作，算法可能改变容器中元素的值，或者在容器内移动元素，但不会改变底层容器的大小。</p>
<h2 id="初识泛型算法"><a href="#初识泛型算法" class="headerlink" title="初识泛型算法"></a>初识泛型算法</h2><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p><code>accumulate</code>函数（定义在头文件<code>numeric</code>中）用于计算一个序列的和。它接受三个参数，前两个参数指定需要求和的元素范围，第三个参数是和的初值（决定加法运算类型和返回值类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">cbegin</span>(), vec.<span class="built_in">cend</span>(), <span class="number">0</span>);</span><br><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">string</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>建议在只读算法中使用<code>cbegin</code>和<code>cend</code>函数。</p>
<p><code>equal</code>函数用于确定两个序列是否保存相同的值。它接受三个迭代器参数，前两个参数指定第一个序列范围，第三个参数指定第二个序列的首元素。<code>equal</code>函数假定第二个序列至少与第一个序列一样长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">equal</span>(roster1.<span class="built_in">cbegin</span>(), roster1.<span class="built_in">cend</span>(), roster2.<span class="built_in">cbegin</span>());</span><br></pre></td></tr></table></figure>

<p>只接受单一迭代器表示第二个操作序列的算法都假定第二个序列至少与第一个序列一样长。</p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p><code>fill</code>函数接受两个迭代器参数表示序列范围，还接受一个值作为第三个参数，它将给定值赋予范围内的每个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>fill_n</code>函数接受单个迭代器参数、一个计数值和一个值，它将给定值赋予迭代器指向位置开始的指定个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>向目的位置迭代器写入数据的算法都假定目的位置足够大，能容纳要写入的元素。</p>
<p>插入迭代器（insert iterator）是一种向容器内添加元素的迭代器。通过插入迭代器赋值时，一个与赋值号右侧值相等的元素会被添加到容器中。</p>
<p><code>back_inserter</code>函数（定义在头文件<code>iterator</code>中）接受一个指向容器的引用，返回与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中。</p>
<p><code>copy</code>函数接受三个迭代器参数，前两个参数指定输入序列，第三个参数指定目的序列的起始位置。它将输入序列中的元素拷贝到目的序列中，返回目的位置迭代器（递增后）的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">sizeof</span>(a1) / <span class="built_in">sizeof</span>(*a1)];     </span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1), <span class="built_in">end</span>(a1), a2);    <span class="comment">// copy a1 into a2</span></span><br></pre></td></tr></table></figure>

<p><code>replace</code>函数接受四个参数，前两个迭代器参数指定输入序列，后两个参数指定要搜索的值和替换值。它将序列中所有等于第一个值的元素都替换为第二个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">replace</span>(ilst.<span class="built_in">begin</span>(), ilst.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>相对于<code>replace</code>，<code>replace_copy</code>函数可以保留原序列不变。它接受第三个迭代器参数，指定调整后序列的保存位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use back_inserter </span></span><br><span class="line"><span class="built_in">replace_copy</span>(ilst.<span class="built_in">cbegin</span>(), ilst.<span class="built_in">cend</span>(), <span class="built_in">back_inserter</span>(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>很多算法都提供“copy”版本，这些版本不会将新元素放回输入序列，而是创建一个新序列保存结果。</p>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p><code>sort</code>函数接受两个迭代器参数，指定排序范围。它利用元素类型的<code>&lt;</code>运算符重新排列元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">elimDups</span><span class="params">(vector&lt;string&gt; &amp;words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">  </span><br><span class="line">    words.<span class="built_in">erase</span>(end_unique, words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unique</code>函数重排输入序列，消除相邻的重复项，返回指向不重复值范围末尾的迭代器。</p>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>默认情况下，很多比较算法使用元素类型的<code>&lt;</code>或<code>==</code>运算符完成操作。可以为这些算法提供自定义操作来代替默认运算符。</p>
<h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>谓词（predicate）是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法使用的谓词分为一元谓词（unary predicate，接受一个参数）和二元谓词（binary predicate，接受两个参数）。接受谓词参数的算法会对输入序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br></pre></td></tr></table></figure>

<p>稳定排序函数<code>stable_sort</code>可以维持输入序列中相等元素的原有顺序。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p><code>find_if</code>函数接受两个迭代器参数和一个谓词参数。迭代器参数用于指定序列范围，之后对序列中的每个元素调用给定谓词，并返回第一个使谓词返回非0值的元素。如果不存在，则返回尾迭代器。</p>
<p>对于一个对象或表达式，如果可以对其使用调用运算符<code>()</code>，则称它为可调用对象（callable object）。可以向算法传递任何类别的可调用对象。</p>
<p>一个<code>lambda</code>表达式表示一个可调用的代码单元，类似未命名的内联函数，但可以定义在函数内部。其形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>capture list</code>（捕获列表）是一个由<code>lambda</code>所在函数定义的局部变量的列表（通常为空）。<code>return type</code>、<code>parameter list</code>和<code>function body</code>与普通函数一样，分别表示返回类型、参数列表和函数体。但与普通函数不同，<code>lambda</code>必须使用尾置返回类型，且不能有默认实参。</p>
<p>定义<code>lambda</code>时可以省略参数列表和返回类型，但必须包含捕获列表和函数体。省略参数列表等价于指定空参数列表。省略返回类型时，若函数体只是一个<code>return</code>语句，则返回类型由返回表达式的类型推断而来。否则返回类型为<code>void</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;    <span class="comment">// prints 42</span></span><br></pre></td></tr></table></figure>

<p><code>lambda</code>可以使用其所在函数的局部变量，但必须先将其包含在捕获列表中。捕获列表只能用于局部非<code>static</code>变量，<code>lambda</code>可以直接使用局部<code>static</code>变量和其所在函数之外声明的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">                    [sz](<span class="type">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>

<p><code>for_each</code>函数接受一个输入序列和一个可调用对象，它对输入序列中的每个元素调用此对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.<span class="built_in">end</span>(),</span><br><span class="line">            [] (<span class="type">const</span> string &amp;s) &#123; cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>被<code>lambda</code>捕获的变量的值是在<code>lambda</code>创建时拷贝，而不是调用时拷贝。在<code>lambda</code>创建后修改局部变量不会影响<code>lambda</code>内对应的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>; </span><br><span class="line"><span class="keyword">auto</span> f = [v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">// j is 42</span></span><br></pre></td></tr></table></figure>

<p><code>lambda</code>可以以引用方式捕获变量，但必须保证<code>lambda</code>执行时变量存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>; </span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f2</span>();  <span class="comment">// j is 0;</span></span><br></pre></td></tr></table></figure>

<p>可以让编译器根据<code>lambda</code>代码隐式捕获函数变量，方法是在捕获列表中写一个<code>&amp;</code>或<code>=</code>符号。<code>&amp;</code>为引用捕获，<code>=</code>为值捕获。</p>
<p>可以混合使用显式捕获和隐式捕获。混合使用时，捕获列表中的第一个元素必须是<code>&amp;</code>或<code>=</code>符号，用于指定默认捕获方式。显式捕获的变量必须使用与隐式捕获不同的方式。</p>
<p><code>lambda</code>捕获列表形式：</p>
<p>默认情况下，对于值方式捕获的变量，<code>lambda</code>不能修改其值。如果希望修改，就必须在参数列表后添加关键字<code>mutable</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>; </span><br><span class="line"><span class="keyword">auto</span> f = [v1] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">// j is 43</span></span><br></pre></td></tr></table></figure>

<p>对于引用方式捕获的变量，<code>lambda</code>是否可以修改依赖于此引用指向的是否是<code>const</code>类型。</p>
<p><code>transform</code>函数接受三个迭代器参数和一个可调用对象。前两个迭代器参数指定输入序列，第三个迭代器参数表示目的位置。它对输入序列中的每个元素调用可调用对象，并将结果写入目的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">            [](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure>

<p>为<code>lambda</code>定义返回类型时，必须使用尾置返回类型。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p><code>bind</code>函数定义在头文件<code>functional</code>中，相当于一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></table></figure>

<p>其中，<code>newCallable</code>本身是一个可调用对象，<code>arg_list</code>是一个以逗号分隔的参数列表，对应给定的<code>callable</code>的参数。之后调用<code>newCallable</code>时，<code>newCallable</code>会再调用<code>callable</code>，并传递给它<code>arg_list</code>中的参数。<code>arg_list</code>中可能包含形如<code>_n</code>的名字，其中<code>n</code>是一个整数。这些参数是占位符，表示<code>newCallable</code>的参数，它们占据了传递给<code>newCallable</code>的参数的位置。数值<code>n</code>表示生成的可调用对象中参数的位置：<code>_1</code>为<code>newCallable</code>的第一个参数，<code>_2</code>为<code>newCallable</code>的第二个参数，依次类推。这些名字都定义在命名空间<code>placeholders</code>中，它又定义在命名空间<code>std</code>中，因此使用时应该进行双重限定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, _1, <span class="number">6</span>);</span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">check6</span>(s);    <span class="comment">// check6(s) calls check_size(s, 6)</span></span><br></pre></td></tr></table></figure>

<p><code>bind</code>函数可以调整给定可调用对象中的参数顺序。</p>
<p>默认情况下，<code>bind</code>函数的非占位符参数被拷贝到<code>bind</code>返回的可调用对象中。但有些类型不支持拷贝操作。</p>
<p>如果希望传递给<code>bind</code>一个对象而又不拷贝它，则必须使用标准库的<code>ref</code>函数。<code>ref</code>函数返回一个对象，包含给定的引用，此对象是可以拷贝的。<code>cref</code>函数生成保存<code>const</code>引用的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> string &amp;s, <span class="type">char</span> c)</span></span>;</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>除了为每种容器定义的迭代器之外，标准库还在头文件<code>iterator</code>中定义了另外几种迭代器。</p>
<ul>
<li><p>插入迭代器（insert iterator）：该类型迭代器被绑定到容器对象上，可用来向容器中插入元素。</p>
</li>
<li><p>流迭代器（stream iterator）：该类型迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</p>
</li>
<li><p>反向迭代器（reverse iterator）：该类型迭代器向后而不是向前移动。除了<code>forward_list</code>之外的标准库容器都有反向迭代器。</p>
</li>
<li><p>移动迭代器（move iterator）：该类型迭代器用来移动容器元素。</p>
</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器，它接受一个容器参数，生成一个插入迭代器。通过插入迭代器赋值时，该迭代器调用容器操作向给定容器的指定位置插入一个元素。</p>
<p>插入迭代器操作：</p>
<p>插入器有三种类型，区别在于元素插入的位置：</p>
<ul>
<li><p><code>back_inserter</code>：创建一个调用<code>push_back</code>操作的迭代器。</p>
</li>
<li><p><code>front_inserter</code>：创建一个调用<code>push_front</code>操作的迭代器。</p>
</li>
<li><p><code>inserter</code>：创建一个调用<code>insert</code>操作的迭代器。此函数接受第二个参数，该参数必须是一个指向给定容器的迭代器，元素会被插入到该参数指向的元素之前。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst2, lst3;  </span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">front_inserter</span>(lst2));</span><br><span class="line"><span class="comment">// after copy completes, lst3 contains 1 2 3 4</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">inserter</span>(lst3, lst3.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>

<h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a><code>iostream</code>迭代器</h3><p><code>istream_iterator</code>从输入流读取数据，<code>ostream_iterator</code>向输出流写入数据。这些迭代器将流当作特定类型的元素序列处理。</p>
<p>创建流迭代器时，必须指定迭代器读写的对象类型。<code>istream_iterator</code>使用<code>&gt;&gt;</code>来读取流，因此<code>istream_iterator</code>要读取的类型必须定义了<code>&gt;&gt;</code>运算符。创建<code>istream_iterator</code>时，可以将其绑定到一个流。如果默认初始化，则创建的是尾后迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span></span>;  </span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; int_eof;    </span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;afile&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;string&gt; <span class="title">str_it</span><span class="params">(in)</span></span>;   </span><br></pre></td></tr></table></figure>

<p>对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。</p>
<p>可以直接使用流迭代器构造容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span>, eof</span>;    </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;    </span><br></pre></td></tr></table></figure>

<p>将<code>istream_iterator</code>绑定到一个流时，标准库并不保证迭代器立即从流读取数据。但可以保证在第一次解引用迭代器之前，从流中读取数据的操作已经完成了。</p>
<p>定义<code>ostream_iterator</code>对象时，必须将其绑定到一个指定的流。不允许定义空的或者表示尾后位置的<code>ostream_iterator</code>。</p>
<p><code>*</code>和<code>++</code>运算符实际上不会对<code>ostream_iterator</code>对象做任何操作。但是建议代码写法与其他迭代器保持一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">    *out_iter++ = e;   </span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>可以为任何定义了<code>&lt;&lt;</code>运算符的类型创建<code>istream_iterator</code>对象，为定义了<code>&gt;&gt;</code>运算符的类型创建<code>ostream_iterator</code>对象。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>递增反向迭代器会移动到前一个元素，递减会移动到后一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); </span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>());</span><br></pre></td></tr></table></figure>

<p>不能从<code>forward_list</code>或流迭代器创建反向迭代器。</p>
<p>调用反向迭代器的<code>base</code>函数可以获得其对应的普通迭代器。</p>
<p>反向迭代器的目的是表示元素范围，而这些范围是不对称的。用普通迭代器初始化反向迭代器，或者给反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同元素。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><h3 id="五类迭代器"><a href="#五类迭代器" class="headerlink" title="五类迭代器"></a>五类迭代器</h3><p>C++标准指定了泛型和数值算法的每个迭代器参数的最小类别。对于迭代器实参来说，其能力必须大于或等于规定的最小类别。向算法传递更低级的迭代器参数会产生错误（大部分编译器不会提示错误）。</p>
<p>迭代器类别：</p>
<ul>
<li><p>输入迭代器（input iterator）：可以读取序列中的元素，只能用于单遍扫描算法。必须支持以下操作：</p>
<ul>
<li><p>用于比较两个迭代器相等性的相等<code>==</code>和不等运算符<code>!=</code>。</p>
</li>
<li><p>用于推进迭代器位置的前置和后置递增运算符<code>++</code>。</p>
</li>
<li><p>用于读取元素的解引用运算符<code>*</code>；解引用只能出现在赋值运算符右侧。</p>
</li>
<li><p>用于读取元素的箭头运算符<code>-&gt;</code>。</p>
</li>
</ul>
</li>
<li><p>输出迭代器（output iterator）：可以读写序列中的元素，只能用于单遍扫描算法，通常指向目的位置。必须支持以下操作：</p>
<ul>
<li><p>用于推进迭代器位置的前置和后置递增运算符<code>++</code>。</p>
</li>
<li><p>用于读取元素的解引用运算符<code>*</code>；解引用只能出现在赋值运算符左侧（向已经解引用的输出迭代器赋值，等价于将值写入其指向的元素）。</p>
</li>
</ul>
</li>
<li><p>前向迭代器（forward iterator）：可以读写序列中的元素。只能在序列中沿一个方向移动。支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此可以使用前向迭代器对序列进行多遍扫描。</p>
</li>
<li><p>双向迭代器（bidirectional iterator）：可以正向&#x2F;反向读写序列中的元素。除了支持所有前向迭代器的操作之外，还支持前置和后置递减运算符<code>--</code>。除<code>forward_list</code>之外的其他标准库容器都提供符合双向迭代器要求的迭代器。</p>
</li>
<li><p>随机访问迭代器（random-access iterator）：可以在常量时间内访问序列中的任何元素。除了支持所有双向迭代器的操作之外，还必须支持以下操作：</p>
<ul>
<li><p>用于比较两个迭代器相对位置的关系运算符<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>。</p>
</li>
<li><p>迭代器和一个整数值的加减法运算<code>+</code>、<code>+=</code>、<code>-</code>、<code>-=</code>，计算结果是迭代器在序列中前进或后退给定整数个元素后的位置。</p>
</li>
<li><p>用于两个迭代器上的减法运算符<code>-</code>，计算得到两个迭代器的距离。</p>
</li>
<li><p>下标运算符<code>[]</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>大多数算法的形参模式是以下四种形式之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alg</span>(beg, end, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, dest, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, beg2, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, beg2, end2, other args);</span><br></pre></td></tr></table></figure>

<p>其中<code>alg</code>是算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于算法操作。<code>dest</code>表示输出范围，<code>beg2</code>和<code>end2</code>表示第二个输入范围。</p>
<p>向输出迭代器写入数据的算法都假定目标空间足够容纳要写入的数据。</p>
<p>接受单独一个迭代器参数表示第二个输入范围的算法都假定从迭代器参数开始的序列至少与第一个输入范围一样大。</p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>接受谓词参数的算法都有附加的<code>_if</code>后缀。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg, end, val);      </span><br><span class="line"><span class="built_in">find_if</span>(beg, end, pred); </span><br></pre></td></tr></table></figure>

<p>将执行结果写入额外目的空间的算法都有<code>_copy</code>后缀。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg, end);              </span><br><span class="line"><span class="built_in">reverse_copy</span>(beg, end, dest);   </span><br></pre></td></tr></table></figure>

<p>一些算法同时提供<code>_copy</code>和<code>_if</code>版本。</p>
<h2 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h2><p>对于<code>list</code>和<code>forward_list</code>类型，应该优先使用成员函数版本的算法，而非通用算法。</p>
<p>链表特有版本的算法操作会改变底层容器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/C++%20Primer%20Chapter%209%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/C++%20Primer%20Chapter%209%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 9 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-24 13:19:45" itemprop="dateCreated datePublished" datetime="2023-03-24T13:19:45+08:00">2023-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-05 20:13:42" itemprop="dateModified" datetime="2023-04-05T20:13:42+08:00">2023-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><ul>
<li><strong>顺序容器</strong>：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</li>
</ul>
<h3 id="顺序容器类型"><a href="#顺序容器类型" class="headerlink" title="顺序容器类型"></a>顺序容器类型</h3><table>
<thead>
<tr>
<th>容器类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><code>vector</code></td>
<td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。</td>
</tr>
<tr>
<td><code>deque</code></td>
<td>双端队列。支持快速随机访问。在头尾位置插入&#x2F;删除速度很快。</td>
</tr>
<tr>
<td><code>list</code></td>
<td>双向链表。只支持双向顺序访问。在<code>list</code>中任何位置进行插入&#x2F;删除操作速度都很快。</td>
</tr>
<tr>
<td><code>forward_list</code></td>
<td>单向链表。只支持单向顺序访问。在链表任何位置进行插入&#x2F;删除操作速度都很快。</td>
</tr>
<tr>
<td><code>array</code></td>
<td>固定大小数组。支持快速随机访问。不能添加或者删除元素。</td>
</tr>
<tr>
<td><code>string</code></td>
<td>与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入&#x2F;删除速度快。</td>
</tr>
</tbody></table>
<ul>
<li>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</li>
<li><code>forward_list</code>和<code>array</code>是新C++标准增加的类型。</li>
<li>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</li>
<li>新标准库的容器比旧版的快得多。</li>
</ul>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>iterator</code></td>
<td>此容器类型的迭代器类型</td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td>可以读取元素但不能修改元素的迭代器类型</td>
</tr>
<tr>
<td><code>size_type</code></td>
<td>无符号整数类型，足够保存此种容器类型最大可能的大小</td>
</tr>
<tr>
<td><code>difference_type</code></td>
<td>带符号整数类型，足够保存两个迭代器之间的距离</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>元素类型</td>
</tr>
<tr>
<td><code>reference</code></td>
<td>元素的左值类型；和<code>value_type &amp;</code>含义相同</td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td>元素的<code>const</code>左值类型，即<code>const value_type &amp;</code></td>
</tr>
</tbody></table>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>C c;</code></td>
<td>默认构造函数，构造空容器</td>
</tr>
<tr>
<td><code>C c1(c2);</code>或<code>C c1 = c2;</code></td>
<td>构造<code>c2</code>的拷贝<code>c1</code></td>
</tr>
<tr>
<td><code>C c(b, e)</code></td>
<td>构造<code>c</code>，将迭代器<code>b</code>和<code>e</code>指定范围内的所有元素拷贝到<code>c</code></td>
</tr>
<tr>
<td><code>C c(a, b, c...)</code></td>
<td>列表初始化<code>c</code></td>
</tr>
<tr>
<td><code>C c(n)</code></td>
<td>只支持顺序容器，且不包括<code>array</code>，包含<code>n</code>个元素，这些元素进行了值初始化</td>
</tr>
<tr>
<td><code>C c(n, t)</code></td>
<td>包含<code>n</code>个初始值为<code>t</code>的元素</td>
</tr>
</tbody></table>
<ul>
<li>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</li>
<li><code>array</code>具有固定大小。</li>
<li>和其他容器不同，默认构造的<code>array</code>是非空的。</li>
<li>直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。</li>
<li>使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。</li>
</ul>
<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和<code>swap</code></h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c1 = c2;</code></td>
<td>将<code>c1</code>中的元素替换成<code>c2</code>中的元素</td>
</tr>
<tr>
<td><code>c1 = &#123;a, b, c...&#125;</code></td>
<td>将<code>c1</code>中的元素替换成列表中的元素（不适用于<code>array</code>）</td>
</tr>
<tr>
<td><code>c1.swap(c2)</code></td>
<td>交换<code>c1</code>和<code>c2</code>的元素</td>
</tr>
<tr>
<td><code>swap(c1, c2)</code></td>
<td>等价于<code>c1.swap(c2)</code></td>
</tr>
<tr>
<td><code>c.assign(b, e)</code></td>
<td>将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素</td>
</tr>
<tr>
<td><code>c.assign(il)</code></td>
<td>将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素</td>
</tr>
<tr>
<td><code>c.assign(n, r)</code></td>
<td>将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</td>
</tr>
</tbody></table>
<ul>
<li>使用非成员版本的<code>swap</code>是一个好习惯。</li>
<li><code>assign</code>操作不适用于关联容器和<code>array</code></li>
</ul>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.size()</code></td>
<td><code>c</code>中元素的数目（不支持<code>forward_list</code>）</td>
</tr>
<tr>
<td><code>c.max_size()</code></td>
<td><code>c</code>中可保存的最大元素数目</td>
</tr>
<tr>
<td><code>c.empty()</code></td>
<td>若<code>c</code>中存储了元素，返回<code>false</code>，否则返回<code>true</code></td>
</tr>
</tbody></table>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.push_back(t)</code></td>
<td>在<code>c</code>尾部创建一个值为<code>t</code>的元素，返回<code>void</code></td>
</tr>
<tr>
<td><code>c.emplace_back(args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.push_front(t)</code></td>
<td>在<code>c</code>头部创建一个值为<code>t</code>的元素，返回<code>void</code></td>
</tr>
<tr>
<td><code>c.emplace_front(args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.insert(p, t)</code></td>
<td>在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</td>
</tr>
<tr>
<td><code>c.emplace(p, args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.insert(p, n, t)</code></td>
<td>在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器；如果<code>n</code>是0，则返回<code>p</code></td>
</tr>
<tr>
<td><code>c.insert(p, b, e)</code></td>
<td>将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前；如果范围为空，则返回<code>p</code></td>
</tr>
<tr>
<td><code>c.insert(p, il)</code></td>
<td><code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前；如果<code>il</code>是空，则返回<code>p</code></td>
</tr>
</tbody></table>
<ul>
<li>因为这些操作会改变大小，因此不适用于<code>array</code>。</li>
<li><code>forward_list</code>有自己专有版本的<code>insert</code>和<code>emplace</code>。</li>
<li><code>forward_list</code>不支持<code>push_back</code>和<code>emplace_back</code>。</li>
<li>当我们用一个对象去初始化容器或者将对象插入到容器时，实际上放入的是对象的拷贝。</li>
<li><code>emplace</code>开头的函数是新标准引入的，这些操作是构造而不是拷贝元素。</li>
<li>传递给<code>emplace</code>的参数必须和元素类型的构造函数相匹配。</li>
</ul>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.back()</code></td>
<td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c.front()</code></td>
<td>返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c[n]</code></td>
<td>返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号证书。若<code>n&gt;=c.size()</code>，则函数行为未定义</td>
</tr>
<tr>
<td><code>c.at(n)</code></td>
<td>返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td>
</tr>
</tbody></table>
<ul>
<li>访问成员函数返回的是引用。</li>
<li><code>at</code>和下标操作只适用于<code>string</code>、<code>vector</code>、<code>deque</code>、<code>array</code>。</li>
<li><code>back</code>不适用于<code>forward_list</code>。</li>
<li>如果希望下标是合法的，可以使用<code>at</code>函数。</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.pop_back()</code></td>
<td>删除<code>c</code>中尾元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td>
</tr>
<tr>
<td><code>c.pop_front()</code></td>
<td>删除<code>c</code>中首元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器<code>b</code>和<code>e</code>范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.clear()</code></td>
<td>删除<code>c</code>中所有元素，返回<code>void</code></td>
</tr>
</tbody></table>
<ul>
<li>会改变容器大小，不适用于<code>array</code>。</li>
<li><code>forward_list</code>有特殊版本的<code>erase</code></li>
<li><code>forward_list</code>不支持<code>pop_back</code></li>
<li><code>vector</code>和<code>string</code>不支持<code>pop_front</code></li>
</ul>
<h3 id="特殊的forwad-list操作"><a href="#特殊的forwad-list操作" class="headerlink" title="特殊的forwad_list操作"></a>特殊的forwad_list操作</h3><ul>
<li>链表在删除元素时需要修改前置节点的内容，双向链表会前驱的指针，但是单向链表没有保存，因此需要增加获取前置节点的方法。</li>
<li><code>forward_list</code>定义了<code>before_begin</code>，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>lst.before_begin()</code></td>
<td>返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td>
</tr>
<tr>
<td><code>lst.cbefore_begin()</code></td>
<td>同上，但是返回的是常量迭代器。</td>
</tr>
<tr>
<td><code>lst.insert_after(p, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象</td>
</tr>
<tr>
<td><code>lst.insert_after(p, n, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td>
</tr>
<tr>
<td><code>lst.insert_after(p, b, e)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围。</td>
</tr>
<tr>
<td><code>lst.insert_after(p, il)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td>
</tr>
<tr>
<td><code>emplace_after(p, args)</code></td>
<td>使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(p)</code></td>
<td>删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(b, e)</code></td>
<td>类似上面，删除对象换成从<code>b</code>到<code>e</code>指定的范围。</td>
</tr>
</tbody></table>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.resize(n)</code></td>
<td>调整<code>c</code>的大小为<code>n</code>个元素，若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td>
</tr>
<tr>
<td><code>c.resize(n, t)</code></td>
<td>调整<code>c</code>的大小为<code>n</code>个元素，任何新添加的元素都初始化为值<code>t</code></td>
</tr>
</tbody></table>
<h3 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.begin()</code>, <code>c.end()</code></td>
<td>返回指向<code>c</code>的首元素和尾元素之后位置的迭代器</td>
</tr>
<tr>
<td><code>c.cbegin()</code>, <code>c.cend()</code></td>
<td>返回<code>const_iterator</code></td>
</tr>
</tbody></table>
<ul>
<li>以<code>c</code>开头的版本是C++11新标准引入的</li>
<li>当不需要写访问时，应该使用<code>cbegin</code>和<code>cend</code>。</li>
</ul>
<h3 id="反向容器的额外成员"><a href="#反向容器的额外成员" class="headerlink" title="反向容器的额外成员"></a>反向容器的额外成员</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>reverse_iterator</code></td>
<td>按逆序寻址元素的迭代器</td>
</tr>
<tr>
<td><code>const_reverse_iterator</code></td>
<td>不能修改元素的逆序迭代器</td>
</tr>
<tr>
<td><code>c.rbegin()</code>, <code>c.rend()</code></td>
<td>返回指向<code>c</code>的尾元素和首元素之前位置的迭代器</td>
</tr>
<tr>
<td><code>c.crbegin()</code>, <code>c.crend()</code></td>
<td>返回<code>const_reverse_iterator</code></td>
</tr>
</tbody></table>
<ul>
<li>不支持<code>forward_list</code></li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>迭代器范围：<code>begin</code>到<code>end</code>，即第一个元素到最后一个元素的后面一个位置。</li>
<li>左闭合区间：<code>[begin, end)</code></li>
<li>左闭合范围蕴含的编程设定：<ul>
<li>如果<code>begin</code>和<code>end</code>相等，则范围为空。</li>
<li>如果二者不等，则范围至少包含一个元素，且<code>begin</code>指向该范围中的第一个元素。</li>
<li>可以对<code>begin</code>递增若干次，使得<code>begin == end</code>。</li>
</ul>
</li>
</ul>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><ul>
<li>在向容器添加元素后：<ul>
<li>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。</li>
<li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。</li>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用依然有效。</li>
</ul>
</li>
<li>在从一个容器中删除元素后：<ul>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器、引用和指针仍然有效。</li>
<li>对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除<code>deque</code>的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是<code>deque</code>的头元素，这些也不会受影响。</li>
<li>对于<code>vector</code>和<code>string</code>，指向被删元素之前的迭代器、引用、指针仍然有效。</li>
<li>注意：当我们删除元素时，尾后迭代器总是会失效。</li>
<li>注意：使用失效的迭代器、指针、引用是严重的运行时错误！</li>
<li>建议：将要求迭代器必须保持有效的程序片段最小化。</li>
<li>建议：不要保存<code>end</code>返回的迭代器。</li>
</ul>
</li>
</ul>
<h3 id="容器内元素的类型约束"><a href="#容器内元素的类型约束" class="headerlink" title="容器内元素的类型约束"></a>容器内元素的类型约束</h3><ul>
<li>元素类型必须支持赋值运算；</li>
<li>元素类型的对象必须可以复制。</li>
<li>除了输入输出标准库类型外，其他所有标准库类型都是有效的容器元素类型。</li>
</ul>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><p><code>vector</code>和<code>string</code>在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。</p>
<h3 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.shrink_to_fit()</code></td>
<td>将<code>capacity()</code>减少到和<code>size()</code>相同大小</td>
</tr>
<tr>
<td><code>c.capacity()</code></td>
<td>不重新分配内存空间的话，<code>c</code>可以保存多少个元素</td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>分配至少能容纳<code>n</code>个元素的内存空间</td>
</tr>
</tbody></table>
<ul>
<li><code>shrink_to_fit</code>只适用于<code>vector</code>、<code>string</code>和<code>deque</code></li>
<li><code>capacity</code>和<code>reverse</code>只适用于<code>vector</code>和<code>string</code>。</li>
</ul>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>string s(cp, n)</code></td>
<td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组</td>
</tr>
<tr>
<td><code>string s(s2, pos2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符的拷贝。若<code>pos2 &gt; s2.size()</code>，则构造函数的行为未定义。</td>
</tr>
<tr>
<td><code>string s(s2, pos2, len2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td>
</tr>
</tbody></table>
<ul>
<li><code>n</code>,<code>len2</code>,<code>pos2</code>都是无符号值。</li>
</ul>
<h3 id="substr操作"><a href="#substr操作" class="headerlink" title="substr操作"></a>substr操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.substr(pos, n)</code></td>
<td>返回一个<code>string</code>，包含<code>s</code>中从<code>pos</code>开始的<code>n</code>个字符的拷贝。<code>pos</code>的默认值是0，<code>n</code>的默认值是<code>s.size() - pos</code>，即拷贝从<code>pos</code>开始的所有字符。</td>
</tr>
</tbody></table>
<h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.insert(pos, args)</code></td>
<td>在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td>
</tr>
<tr>
<td><code>s.erase(pos, len)</code></td>
<td>删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.assign(args)</code></td>
<td>将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.append(args)</code></td>
<td>将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.replace(range, args)</code></td>
<td>删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td>
</tr>
</tbody></table>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><ul>
<li><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</li>
<li>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的<code>static</code>成员（类型是<code>string::size_type</code>，初始化值是-1，也就是<code>string</code>最大的可能大小）。</li>
</ul>
<table>
<thead>
<tr>
<th>搜索操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.find(args)</code></td>
<td>查找<code>s</code>中<code>args</code>第一次出现的位置</td>
</tr>
<tr>
<td><code>s.rfind(args)</code></td>
<td>查找<code>s</code>中<code>args</code>最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_last_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找第一个不在<code>args</code>中的字符</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找最后一个不在<code>args</code>中的字符</td>
</tr>
</tbody></table>
<p>args必须是一下的形式之一：</p>
<table>
<thead>
<tr>
<th><code>args</code>形式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找字符<code>c</code>。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>s2, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找字符串<code>s</code>。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>cp, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的以空字符结尾的C风格字符串。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>cp, pos, n</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的前<code>n</code>个字符。<code>pos</code>和<code>n</code>无默认值。</td>
</tr>
</tbody></table>
<h3 id="s-compare的几种参数形式"><a href="#s-compare的几种参数形式" class="headerlink" title="s.compare的几种参数形式"></a>s.compare的几种参数形式</h3><p>逻辑类似于C标准库的<code>strcmp</code>函数，根据<code>s</code>是等于、大于还是小于参数指定的字符串，<code>s.compare</code>返回0、正数或负数。</p>
<table>
<thead>
<tr>
<th>参数形式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s2</code></td>
<td>比较<code>s</code>和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2, pos2, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td>
</tr>
<tr>
<td><code>cp</code></td>
<td>比较<code>s</code>和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的地址开始<code>n2</code>个字符</td>
</tr>
</tbody></table>
<h3 id="string和数值转换"><a href="#string和数值转换" class="headerlink" title="string和数值转换"></a>string和数值转换</h3><table>
<thead>
<tr>
<th>转换</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>to_string(val)</code></td>
<td>一组重载函数，返回数值<code>val</code>的<code>string</code>表示。<code>val</code>可以使任何算术类型。对每个浮点类型和<code>int</code>或更大的整型，都有相应版本的<code>to_string()</code>。和往常一样，小整型会被提升。</td>
</tr>
<tr>
<td><code>stoi(s, p, b)</code></td>
<td>返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，<code>b</code>是转换所用的基数。返回<code>int</code></td>
</tr>
<tr>
<td><code>stol(s, p, b)</code></td>
<td>返回<code>long</code></td>
</tr>
<tr>
<td><code>stoul(s, p, b)</code></td>
<td>返回<code>unsigned long</code></td>
</tr>
<tr>
<td><code>stoll(s, p, b)</code></td>
<td>返回<code>long long</code></td>
</tr>
<tr>
<td><code>stoull(s, p, b)</code></td>
<td>返回<code>unsigned long long</code></td>
</tr>
<tr>
<td><code>stof(s, p)</code></td>
<td>返回<code>s</code>起始子串（表示浮点数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0。返回<code>float</code></td>
</tr>
<tr>
<td><code>stod(s, p)</code></td>
<td>返回<code>double</code></td>
</tr>
<tr>
<td><code>stold(s, p)</code></td>
<td>返回<code>long double</code></td>
</tr>
</tbody></table>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><ul>
<li>适配器是使一事物的行为类似于另一事物的行为的一种机制，例如<code>stack</code>可以使任何一种顺序容器以栈的方式工作。</li>
<li>初始化 <code>deque&lt;int&gt; deq; stack&lt;int&gt; stk(deq);</code> 从<code>deq</code>拷贝元素到<code>stk</code>。</li>
<li>创建适配器时，指定一个顺序容器，可以覆盖默认的基础容器： <code>stack&lt;string, vector&lt;string&gt; &gt; str_stk;</code>。</li>
</ul>
<h3 id="适配器的通用操作和类型"><a href="#适配器的通用操作和类型" class="headerlink" title="适配器的通用操作和类型"></a>适配器的通用操作和类型</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>size_type</code></td>
<td>一种类型，须以保存当前类型的最大对象的大小</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>元素类型</td>
</tr>
<tr>
<td><code>container_type</code></td>
<td>实现适配器的底层容器类型</td>
</tr>
<tr>
<td><code>A a;</code></td>
<td>创建一个名为<code>a</code>的空适配器</td>
</tr>
<tr>
<td><code>A a(c)</code></td>
<td>创建一个名为<code>a</code>的适配器，带有容器<code>c</code>的一个拷贝</td>
</tr>
<tr>
<td>关系运算符</td>
<td>每个适配器都支持所有关系运算符：<code>==</code>、<code>!=</code>、<code>&lt;</code>、 <code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>这些运算符返回底层容器的比较结果</td>
</tr>
<tr>
<td><code>a.empty()</code></td>
<td>若<code>a</code>包含任何元素，返回<code>false</code>;否则返回<code>true</code></td>
</tr>
<tr>
<td><code>a.size()</code></td>
<td>返回<code>a</code>中的元素数目</td>
</tr>
<tr>
<td><code>swap(a, b)</code></td>
<td>交换<code>a</code>和<code>b</code>的内容，<code>a</code>和<code>b</code>必须有相同类型，包括底层容器类型也必须相同</td>
</tr>
<tr>
<td><code>a.swap(b)</code></td>
<td>同上</td>
</tr>
</tbody></table>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.pop()</code></td>
<td>删除栈顶元素，不返回。</td>
</tr>
<tr>
<td><code>s.push(item)</code></td>
<td>创建一个新元素，压入栈顶，该元素通过拷贝或移动<code>item</code>而来</td>
</tr>
<tr>
<td><code>s.emplace(args)</code></td>
<td>同上，但元素由<code>args</code>来构造。</td>
</tr>
<tr>
<td><code>s.top()</code></td>
<td>返回栈顶元素，不删除。</td>
</tr>
</tbody></table>
<ul>
<li>定义在<code>stack</code>头文件中。</li>
<li><code>stack</code>默认基于<code>deque</code>实现，也可以在<code>list</code>或<code>vector</code>之上实现。</li>
</ul>
<h3 id="queue和priority-queue"><a href="#queue和priority-queue" class="headerlink" title="queue和priority_queue"></a>queue和priority_queue</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>q.pop()</code></td>
<td>删除队首元素，但不返回。</td>
</tr>
<tr>
<td><code>q.front()</code></td>
<td>返回队首元素的值，不删除。</td>
</tr>
<tr>
<td><code>q.back()</code></td>
<td>返回队尾元素的值，不删除。只适用于<code>queue</code></td>
</tr>
<tr>
<td><code>q.top()</code></td>
<td>返回具有最高优先级的元素值，不删除。</td>
</tr>
<tr>
<td><code>q.push(item)</code></td>
<td>在队尾压入一个新元素。</td>
</tr>
<tr>
<td><code>q.emplace(args)</code></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>定义在<code>queue</code>头文件中。</li>
<li><code>queue</code>默认基于<code>deque</code>实现，<code>priority_queue</code>默认基于<code>vector</code>实现。</li>
<li><code>queue</code>可以在<code>list</code>或<code>vector</code>之上实现，<code>priority_queue</code>也可以用<code>deque</code>实现。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/C++%20Primer%20Chapter%208%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/C++%20Primer%20Chapter%208%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 8 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-24 13:12:13" itemprop="dateCreated datePublished" datetime="2023-03-24T13:12:13+08:00">2023-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-05 20:12:25" itemprop="dateModified" datetime="2023-04-05T20:12:25+08:00">2023-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><h2 id="前面章节已经在用的IO库设施"><a href="#前面章节已经在用的IO库设施" class="headerlink" title="前面章节已经在用的IO库设施"></a>前面章节已经在用的IO库设施</h2><ul>
<li><strong>istream</strong>：输入流类型，提供输入操作。</li>
<li><strong>ostream</strong>：输出流类型，提供输出操作</li>
<li><strong>cin</strong>：一个<code>istream</code>对象，从标准输入读取数据。</li>
<li><strong>cout</strong>：一个<code>ostream</code>对象，向标准输出写入数据。</li>
<li><strong>cerr</strong>：一个<code>ostream</code>对象，向标准错误写入消息。</li>
<li><strong>&gt;&gt;运算符</strong>：用来从一个<code>istream</code>对象中读取输入数据。</li>
<li><strong>&lt;&lt;运算符</strong>：用来向一个<code>ostream</code>对象中写入输出数据。</li>
<li><strong>getline函数</strong>：从一个给定的<code>istream</code>对象中读取一行数据，存入到一个给定的<code>string</code>对象中。</li>
</ul>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><h3 id="标准库定义的IO类型"><a href="#标准库定义的IO类型" class="headerlink" title="标准库定义的IO类型"></a>标准库定义的IO类型</h3><ul>
<li><code>iostream</code>头文件：从标准流中读写数据，<code>istream</code>、<code>ostream</code>等。</li>
<li><code>fstream</code>头文件：从文件中读写数据，<code>ifstream</code>、<code>ofstream</code>等。</li>
<li><code>sstream</code>头文件：从字符串中读写数据，<code>istringstream</code>、<code>ostringstream</code></li>
</ul>
<h3 id="IO对象不可复制或赋值"><a href="#IO对象不可复制或赋值" class="headerlink" title="IO对象不可复制或赋值"></a>IO对象不可复制或赋值</h3><ul>
<li>1.IO对象不能存在容器里.</li>
<li>2.形参和返回类型也不能是流类型。</li>
<li>3.形参和返回类型一般是流的<strong>引用</strong>。</li>
<li>4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</li>
</ul>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>strm:iostate</code></td>
<td>是一种机器无关的<strong>类型</strong>，提供了表达条件状态的完整功能</td>
</tr>
<tr>
<td><code>strm:badbit</code></td>
<td>用来指出流已经崩溃</td>
</tr>
<tr>
<td><code>strm:failbit</code></td>
<td>用来指出一个IO操作失败了</td>
</tr>
<tr>
<td><code>strm:eofbit</code></td>
<td>用来指出流到达了文件结束</td>
</tr>
<tr>
<td><code>strm:goodbit</code></td>
<td>用来指出流未处于错误状态，此值保证为零</td>
</tr>
<tr>
<td><code>s.eof()</code></td>
<td>若流<code>s</code>的<code>eofbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.fail()</code></td>
<td>若流<code>s</code>的<code>failbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.bad()</code></td>
<td>若流<code>s</code>的<code>badbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.good()</code></td>
<td>若流<code>s</code>处于有效状态，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>将流<code>s</code>中所有条件状态位复位，将流的状态设置成有效，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.clear(flags)</code></td>
<td>将流<code>s</code>中指定的条件状态位复位，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.setstate(flags)</code></td>
<td>根据给定的标志位，将流<code>s</code>中对应的条件状态位置位，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.rdstate()</code></td>
<td>返回流<code>s</code>的当前条件状态，返回值类型为<code>strm::iostate</code></td>
</tr>
</tbody></table>
<p>上表中，<code>strm</code>是一种IO类型，（如<code>istream</code>）， <code>s</code>是一个流对象。</p>
<h3 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h3><ul>
<li>每个输出流都管理一个缓冲区，执行输出的代码，文本串可能立即打印出来，也可能被操作系统保存在缓冲区内，随后再打印。</li>
<li>刷新缓冲区，可以使用如下IO操纵符：<ul>
<li><code>endl</code>：输出一个换行符并刷新缓冲区。</li>
<li><code>flush</code>：刷新流，单不添加任何字符。</li>
<li><code>ends</code>：在缓冲区插入空字符<code>null</code>，然后刷新。</li>
<li><code>unitbuf</code>：告诉流接下来每次操作之后都要进行一次<code>flush</code>操作。</li>
<li><code>nounitbuf</code>：回到正常的缓冲方式。</li>
</ul>
</li>
</ul>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><ul>
<li>头文件<code>fstream</code>定义了三个类型来支持文件IO：<ul>
<li><code>ifstream</code>从一个给定文件读取数据。</li>
<li><code>ofstream</code>向一个给定文件写入数据。</li>
<li><code>fstream</code>可以读写给定文件。</li>
</ul>
</li>
<li><strong>文件流</strong>：需要读写文件时，必须定义自己的文件流对象，并绑定在需要的文件上。</li>
</ul>
<h3 id="fstream特有的操作"><a href="#fstream特有的操作" class="headerlink" title="fstream特有的操作"></a>fstream特有的操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>fstream fstrm;</code></td>
<td>创建一个未绑定的文件流。</td>
</tr>
<tr>
<td><code>fstream fstrm(s);</code></td>
<td>创建一个文件流，并打开名为<code>s</code>的文件，<code>s</code>可以是<code>string</code>也可以是<code>char</code>指针</td>
</tr>
<tr>
<td><code>fstream fstrm(s, mode);</code></td>
<td>与前一个构造函数类似，但按指定<code>mode</code>打开文件</td>
</tr>
<tr>
<td><code>fstrm.open(s)</code></td>
<td>打开名为<code>s</code>的文件，并和<code>fstrm</code>绑定</td>
</tr>
<tr>
<td><code>fstrm.close()</code></td>
<td>关闭和<code>fstrm</code>绑定的文件</td>
</tr>
<tr>
<td><code>fstrm.is_open()</code></td>
<td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody></table>
<p>上表中，<code>fstream</code>是头文件<code>fstream</code>中定义的一个类型，<code>fstrm</code>是一个文件流对象。</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><table>
<thead>
<tr>
<th>文件模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>in</code></td>
<td>以读的方式打开</td>
</tr>
<tr>
<td><code>out</code></td>
<td>以写的方式打开</td>
</tr>
<tr>
<td><code>app</code></td>
<td>每次写操作前均定位到文件末尾</td>
</tr>
<tr>
<td><code>ate</code></td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td><code>trunc</code></td>
<td>截断文件</td>
</tr>
<tr>
<td><code>binary</code></td>
<td>以二进制方式进行IO操作。</td>
</tr>
</tbody></table>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><ul>
<li>头文件<code>sstream</code>定义了三个类型来支持内存IO：<ul>
<li><code>istringstream</code>从<code>string</code>读取数据。</li>
<li><code>ostringstream</code>向<code>string</code>写入数据。</li>
<li><code>stringstream</code>可以读写给定<code>string</code>。</li>
</ul>
</li>
</ul>
<h3 id="stringstream特有的操作"><a href="#stringstream特有的操作" class="headerlink" title="stringstream特有的操作"></a>stringstream特有的操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>sstream strm</code></td>
<td>定义一个未绑定的<code>stringstream</code>对象</td>
</tr>
<tr>
<td><code>sstream strm(s)</code></td>
<td>用<code>s</code>初始化对象</td>
</tr>
<tr>
<td><code>strm.str()</code></td>
<td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td>
</tr>
<tr>
<td><code>strm.str(s)</code></td>
<td>将<code>s</code>拷贝到<code>strm</code>中，返回<code>void</code></td>
</tr>
</tbody></table>
<p>上表中<code>sstream</code>是头文件<code>sstream</code>中任意一个类型。<code>s</code>是一个<code>string</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/13/C++%20Primer%20Chapter%207%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/C++%20Primer%20Chapter%207%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 7 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-13 16:22:48" itemprop="dateCreated datePublished" datetime="2023-03-13T16:22:48+08:00">2023-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-31 21:39:29" itemprop="dateModified" datetime="2023-03-31T21:39:29+08:00">2023-03-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="设计Sales-data类"><a href="#设计Sales-data类" class="headerlink" title="设计Sales_data类"></a>设计Sales_data类</h3><p>类的用户是程序员，而非应用程序的最终使用者。</p>
<h3 id="定义改进的Sales-data类"><a href="#定义改进的Sales-data类" class="headerlink" title="定义改进的Sales_data类"></a>定义改进的Sales_data类</h3><p>成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数通过一个名为<code>this</code>的隐式额外参数来访问调用它的对象。<code>this</code>参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用<code>this</code>指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>()</span><br><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total)</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>this</code>的类型是指向类类型非常量版本的常量指针。<code>this</code>也遵循初始化规则，所以默认不能把<code>this</code>绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。</p>
<p>C++允许在成员函数的参数列表后面添加关键字<code>const</code>，表示<code>this</code>是一个指向常量的指针。使用关键字<code>const</code>的成员函数被称作常量成员函数（const member function）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Sales_data::isbn</span><span class="params">(<span class="type">const</span> Sales_data *<span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量对象和指向常量对象的引用或指针都只能调用常量成员函数。</p>
<p>类本身就是一个作用域，成员函数的定义嵌套在类的作用域之内。编译器处理类时，会先编译成员声明，再编译成员函数体（如果有的话），因此成员函数可以随意使用类的其他成员而无须在意这些成员的出现顺序。</p>
<p>在类的外部定义成员函数时，成员函数的定义必须与它的声明相匹配。如果成员函数被声明为常量成员函数，那么它的定义也必须在参数列表后面指定<code>const</code>属性。同时，类外部定义的成员名字必须包含它所属的类名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以定义返回<code>this</code>对象的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;   <span class="comment">// add the members of rhs into</span></span><br><span class="line">    revenue += rhs.revenue;     <span class="comment">// the members of &#x27;this&#x27; object</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">// return the object on which the function was called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><p>类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。</p>
<p>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。</p>
<p>一般来说，执行输出任务的函数应该尽量减少对格式的控制。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。只要类的对象被创建，就会执行构造函数。</p>
<p>构造函数的名字和类名相同，没有返回类型，且不能被声明为<code>const</code>函数。构造函数在<code>const</code>对象的构造过程中可以向其写值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类通过默认构造函数（default constructor）来控制默认初始化过程，默认构造函数无须任何实参。</p>
<p>如果类没有显式地定义构造函数，则编译器会为类隐式地定义一个默认构造函数，该构造函数也被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，合成的默认构造函数初始化数据成员的规则如下：</p>
<ul>
<li><p>如果存在类内初始值，则用它来初始化成员。</p>
</li>
<li><p>否则默认初始化该成员。</p>
</li>
</ul>
<p>某些类不能依赖于合成的默认构造函数。</p>
<ul>
<li><p>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。</p>
</li>
<li><p>如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。</p>
</li>
<li><p>编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。</p>
</li>
</ul>
<p>在C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加<code>=default</code>来要求编译器生成构造函数。其中<code>=default</code>既可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果<code>=default</code>在类的内部，则默认构造函数是内联的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>构造函数初始值列表（constructor initializer list）负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(<span class="number">0</span>), <span class="built_in">revenue</span>(<span class="number">0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>编译器能合成拷贝、赋值和析构函数，但是对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用访问说明符（access specifier）可以加强类的封装性：</p>
<ul>
<li><p>定义在<code>public</code>说明符之后的成员在整个程序内都可以被访问。<code>public</code>成员定义类的接口。</p>
</li>
<li><p>定义在<code>private</code>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。<code>private</code>部分封装了类的实现细节。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// access specifier added</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// access specifier added</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>; &#125;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个类可以包含零或多个访问说明符，每个访问说明符指定了接下来的成员的访问级别，其有效范围到出现下一个访问说明符或类的结尾处为止。</p>
<p>使用关键字<code>struct</code>定义类时，定义在第一个访问说明符之前的成员是<code>public</code>的；而使用关键字<code>class</code>时，这些成员是<code>private</code>的。二者唯一的区别就是默认访问权限不同。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或函数访问它的非公有成员，方法是使用关键字<code>friend</code>将其他类或函数声明为它的友元。</p>
<p>友元声明只能出现在类定义的内部，具体位置不限。友元不是类的成员，也不受它所在区域访问级别的约束。</p>
<p>通常情况下，最好在类定义开始或结束前的位置集中声明友元。</p>
<p>封装的好处：</p>
<ul>
<li><p>确保用户代码不会无意间破坏封装对象的状态。</p>
</li>
<li><p>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</p>
</li>
</ul>
<p>友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。如果希望类的用户能调用某个友元函数，就必须在友元声明之外再专门对函数进行一次声明（部分编译器没有该限制）。</p>
<p>为了使友元对类的用户可见，通常会把友元的声明（类的外部）与类本身放在同一个头文件中。</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>由类定义的类型名字和其他成员一样存在访问限制，可以是<code>public</code>或<code>private</code>中的一种。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pos = std::string::size_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与普通成员不同，用来定义类型的成员必须先定义后使用。类型成员通常位于类起始处。</p>
<p>定义在类内部的成员函数是自动内联的。</p>
<p>如果需要显式声明内联成员函数，建议只在类外部定义的位置说明<code>inline</code>。</p>
<p><code>inline</code>成员函数该与类定义在同一个头文件中。</p>
<p>使用关键字<code>mutable</code>可以声明可变数据成员（mutable data member）。可变数据成员永远不会是<code>const</code>的，即使它在<code>const</code>对象内。因此<code>const</code>成员函数可以修改可变成员的值。</p>
<p>提供类内初始值时，必须使用<code>=</code>或花括号形式。</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p><code>const</code>成员函数如果以引用形式返回<code>*this</code>，则返回类型是常量引用。</p>
<p>通过区分成员函数是否为<code>const</code>的，可以对其进行重载。在常量对象上只能调用<code>const</code>版本的函数；在非常量对象上，尽管两个版本都能调用，但会选择非常量版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; os &lt;&lt; contents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">myScreen</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Screen <span class="title">blank</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>).<span class="built_in">display</span>(cout);  </span><br><span class="line">blank.<span class="built_in">display</span>(cout);   </span><br></pre></td></tr></table></figure>

<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类定义了唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。</p>
<p>可以仅仅声明一个类而暂时不定义它。这种声明被称作前向声明（forward declaration），用于引入类的名字。在类声明之后定义之前都是一个不完全类型（incomplete type）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;  </span><br></pre></td></tr></table></figure>

<p>可以定义指向不完全类型的指针或引用，也可以声明（不能定义）以不完全类型作为参数或返回类型的函数。</p>
<p>只有当类全部完成后才算被定义，所以一个类的成员类型不能是该类本身。但是一旦类的名字出现，就可以被认为是声明过了，因此类可以包含指向它自身类型的引用或指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link_screen</span></span><br><span class="line">&#123;</span><br><span class="line">    Screen window;</span><br><span class="line">    Link_screen *next;</span><br><span class="line">    Link_screen *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>除了普通函数，类还可以把其他类或其他类的成员函数声明为友元。友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Window_mgr members can access the private parts of class Screen</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    <span class="comment">// ... rest of the Screen class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>友元函数可以直接定义在类的内部，这种函数是隐式内联的。但是必须在类外部提供相应声明令函数可见。</p>
<p>友元关系不存在传递性。</p>
<p>把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。</p>
<p>如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>当成员函数定义在类外时，返回类型中使用的名字位于类的作用域之外，此时返回类型必须指明它是哪个类的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// add a Screen to the window and returns its index</span></span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="type">const</span> Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    screens.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="名字查找与作用域"><a href="#名字查找与作用域" class="headerlink" title="名字查找与作用域"></a>名字查找与作用域</h3><p>成员函数体直到整个类可见后才会被处理，因此它能使用类中定义的任何名字。</p>
<p>声明中使用的名字，包括返回类型或参数列表，都必须确保使用前可见。</p>
<p>如果类的成员使用了外层作用域的某个名字，而该名字表示一种类型，则类不能在之后重新定义该名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125; <span class="comment">// uses Money from the outer scop</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> Money; <span class="comment">// error: cannot redefine Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类型名定义通常出现在类起始处，这样能确保所有使用该类型的成员都位于类型名定义之后。</p>
<p>成员函数中名字的解析顺序：</p>
<ul>
<li><p>在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才会被考虑。</p>
</li>
<li><p>如果在成员函数内没有找到，则会在类内继续查找，这时会考虑类的所有成员。</p>
</li>
<li><p>如果类内也没有找到，会在成员函数定义之前的作用域查找。</p>
</li>
</ul>
<p>可以通过作用域运算符<code>::</code>或显式<code>this</code>指针来强制访问被隐藏的类成员。</p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>如果没有在构造函数初始值列表中显式初始化成员，该成员会在构造函数体之前执行默认初始化。</p>
<p>如果成员是<code>const</code>、引用，或者是某种未定义默认构造函数的类类型，必须在初始值列表中将其初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok: explicitly initialize reference and const members</span></span><br><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="type">int</span> ii): <span class="built_in">i</span>(ii), <span class="built_in">ci</span>(ii), <span class="built_in">ri</span>(i) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。</p>
<p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11扩展了构造函数初始值功能，可以定义委托构造函数。委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s = <span class="string">&quot;&quot;</span>): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="comment">// remaining constructors unchanged</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> rev):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(rev*cnt) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) &#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>当对象被默认初始化或值初始化时会自动执行默认构造函数。</p>
<p>默认初始化的发生情况：</p>
<ul>
<li><p>在块作用域内不使用初始值定义非静态变量或数组。</p>
</li>
<li><p>类本身含有类类型的成员且使用合成默认构造函数。</p>
</li>
<li><p>类类型的成员没有在构造函数初始值列表中显式初始化。</p>
</li>
</ul>
<p>值初始化的发生情况：</p>
<ul>
<li><p>数组初始化时提供的初始值数量少于数组大小。</p>
</li>
<li><p>不使用初始值定义局部静态变量。</p>
</li>
<li><p>通过<code>T()</code>形式（<code>T</code>为类型）的表达式显式地请求值初始化。</p>
</li>
</ul>
<p>类必须包含一个默认构造函数。</p>
<p>如果想定义一个使用默认构造函数进行初始化的对象，应该去掉对象名后的空括号对。</p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为转换构造函数（converting constructor）。</p>
<p>编译器只会自动执行一步类型转换。</p>
<p>在要求隐式转换的程序上下文中，可以通过将构造函数声明为<code>explicit</code>的加以阻止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>: bookNo(s) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>explicit</code>关键字只对接受一个实参的构造函数有效。</p>
<p>只能在类内声明构造函数时使用<code>explicit</code>关键字，在类外定义时不能重复。</p>
<p>执行拷贝初始化时（使用<code>=</code>）会发生隐式转换，所以<code>explicit</code>构造函数只能用于直接初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span> <span class="params">(null_book)</span></span>;   <span class="comment">// ok: direct initialization</span></span><br><span class="line">Sales_data item2 = null_book;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>explicit</code>构造函数显式地强制转换类型。</p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类满足如下条件：</p>
<ul>
<li><p>所有成员都是<code>public</code>的。</p>
</li>
<li><p>没有定义任何构造函数。</p>
</li>
<li><p>没有类内初始值。</p>
</li>
<li><p>没有基类。</p>
</li>
<li><p>没有虚函数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用一个用花括号包围的成员初始值列表初始化聚合类的数据成员。初始值顺序必须与声明顺序一致。如果初始值列表中的元素个数少于类的成员个数，则靠后的成员被值初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val1.ival = 0; val1.s = string(&quot;Anna&quot;)</span></span><br><span class="line">Data val1 = &#123; <span class="number">0</span>, <span class="string">&quot;Anna&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p>数据成员都是字面值类型的聚合类是字面值常量类。或者一个类不是聚合类，但符合下列条件，则也是字面值常量类：</p>
<ul>
<li><p>数据成员都是字面值类型。</p>
</li>
<li><p>类至少含有一个<code>constexpr</code>构造函数。</p>
</li>
<li><p>如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</p>
</li>
<li><p>类必须使用析构函数的默认定义。</p>
</li>
</ul>
<p><code>constexpr</code>构造函数用于生成<code>constexpr</code>对象以及<code>constexpr</code>函数的参数或返回类型。</p>
<p><code>constexpr</code>构造函数必须初始化所有数据成员，初始值使用<code>constexpr</code>构造函数或常量表达式。</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>使用关键字<code>static</code>可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于静态成员不与任何对象绑定，因此静态成员函数不能声明为<code>const</code>的，也不能在静态成员函数内使用<code>this</code>指针。</p>
<p>用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。</p>
<p>在类外部定义静态成员时，不能重复<code>static</code>关键字，其只能用于类内部的声明语句。</p>
<p>由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></table></figure>

<p>建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。</p>
<p>尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供<code>const</code>整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的<code>constexpr</code>。初始值必须是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>;  <span class="comment">// period is a constant</span></span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>静态数据成员的类型可以是它所属的类类型。</p>
<p>可以使用静态成员作为函数的默认实参。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/C++%20Primer%20Chapter%206%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/09/C++%20Primer%20Chapter%206%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 6 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-09 19:31:21" itemprop="dateCreated datePublished" datetime="2023-03-09T19:31:21+08:00">2023-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-31 21:30:43" itemprop="dateModified" datetime="2023-03-31T21:30:43+08:00">2023-03-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><ul>
<li><strong>函数定义</strong>：包括返回类型、函数名字和0个或者多个<strong>形参</strong>（parameter）组成的列表和函数体。</li>
<li><strong>调用运算符</strong>：调用运算符的形式是一对圆括号 <code>()</code>，作用于一个表达式，该表达式是函数或者指向函数的指针。</li>
<li>圆括号内是用逗号隔开的<strong>实参</strong>（argument）列表。</li>
<li>函数调用过程：<ul>
<li>1.主调函数（calling function）的执行被中断。</li>
<li>2.被调函数（called function）开始执行。</li>
</ul>
</li>
<li><strong>形参和实参</strong>：形参和实参的<strong>个数</strong>和<strong>类型</strong>必须匹配上。</li>
<li><strong>返回类型</strong>： <code>void</code>表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。</li>
</ul>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><ul>
<li><strong>名字</strong>：名字的作用于是程序文本的一部分，名字在其中可见。</li>
<li><strong>生命周期</strong>：对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
<li><strong>局部变量</strong>（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是<strong>隐藏</strong>的。</li>
<li><strong>自动对象</strong>：只存在于块执行期间的对象。当块的执行结束后，它的值就变成<strong>未定义</strong>的了。</li>
<li><strong>局部静态对象</strong>： <code>static</code>类型的局部变量，生命周期贯穿函数调用前后。</li>
</ul>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><ul>
<li><strong>函数声明</strong>：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称<strong>函数原型</strong>。</li>
<li><strong>在头文件中进行函数声明</strong>：建议变量在头文件中声明；在源文件中定义。</li>
<li><strong>分离编译</strong>： <code>CC a.cc b.cc</code>直接编译生成可执行文件；<code>CC -c a.cc b.cc</code>编译生成对象代码<code>a.o b.o</code>； <code>CC a.o b.o</code>编译生成可执行文件。</li>
</ul>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li>形参初始化的机理和变量初始化一样。</li>
<li><strong>引用传递</strong>（passed by reference）：又称传引用调用（called by reference），指<strong>形参是引用类型</strong>，引用形参是它对应的实参的别名。</li>
<li><strong>值传递</strong>（passed by value）：又称传值调用（called by value），指实参的值是通过<strong>拷贝</strong>传递给形参。</li>
</ul>
<h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><ul>
<li>当初始化一个非引用类型的变量时，初始值被拷贝给变量。</li>
<li>函数对形参做的所有操作都不会影响实参。</li>
<li><strong>指针形参</strong>：常用在C中，<code>C++</code>建议使用引用类型的形参代替指针。</li>
</ul>
<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><ul>
<li>通过使用引用形参，允许函数改变一个或多个实参的值。</li>
<li>引用形参直接关联到绑定的对象，而非对象的副本。</li>
<li>使用引用形参可以用于<strong>返回额外的信息</strong>。</li>
<li>经常用引用形参来避免不必要的复制。</li>
<li><code>void swap(int &amp;v1, int &amp;v2)</code></li>
<li>如果无需改变引用形参的值，最好将其声明为常量引用。</li>
</ul>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><ul>
<li>形参的顶层<code>const</code>被忽略。<code>void func(const int i);</code>调用时既可以传入<code>const int</code>也可以传入<code>int</code>。</li>
<li>我们可以使用非常量初始化一个底层<code>const</code>对象，但是反过来不行。</li>
<li>在函数中，不能改变实参的<strong>局部副本</strong>。</li>
<li>尽量使用常量引用。</li>
</ul>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><ul>
<li>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</li>
<li>要注意数组的实际长度，不能越界。</li>
</ul>
<h3 id="main处理命令行选项"><a href="#main处理命令行选项" class="headerlink" title="main处理命令行选项"></a>main处理命令行选项</h3><ul>
<li><code>int main(int argc, char *argv[])&#123;...&#125;</code></li>
<li>第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。</li>
</ul>
<h3 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h3><p><code>initializer_list</code>提供的操作（<code>C++11</code>）：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>initializer_list&lt;T&gt; lst;</code></td>
<td>默认初始化；<code>T</code>类型元素的空列表</td>
</tr>
<tr>
<td><code>initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;</code></td>
<td><code>lst</code>的元素数量和初始值一样多；<code>lst</code>的元素是对应初始值的副本；列表中的元素是<code>const</code>。</td>
</tr>
<tr>
<td><code>lst2(lst)</code></td>
<td>拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</td>
</tr>
<tr>
<td><code>lst2 = lst</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>lst.size()</code></td>
<td>列表中的元素数量</td>
</tr>
<tr>
<td><code>lst.begin()</code></td>
<td>返回指向<code>lst</code>中首元素的指针</td>
</tr>
<tr>
<td><code>lst.end()</code></td>
<td>返回指向<code>lst</code>中微元素下一位置的指针</td>
</tr>
</tbody></table>
<p><code>initializer_list</code>使用demo：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_msg</span><span class="params">(ErrCode e, initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; e.msg &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bed = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++ beg)</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">err_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">0</span>), &#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;okay&#125;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所有实参类型相同，可以使用 <code>initializer_list</code>的标准库类型。</li>
<li>实参类型不同，可以使用<code>可变参数模板</code>。</li>
<li>省略形参符： <code>...</code>，便于<code>C++</code>访问某些C代码，这些C代码使用了 <code>varargs</code>的C标准功能。</li>
</ul>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>没有返回值的 <code>return</code>语句只能用在返回类型是 <code>void</code>的函数中，返回 <code>void</code>的函数不要求非得有 <code>return</code>语句。</p>
<h3 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h3><ul>
<li><code>return</code>语句的返回值的类型必须和函数的返回类型相同，或者能够<strong>隐式地</strong>转换成函数的返回类型。</li>
<li>值的返回：返回的值用于初始化调用点的一个<strong>临时量</strong>，该临时量就是函数调用的结果。</li>
<li><strong>不要返回局部对象的引用或指针</strong>。</li>
<li><strong>引用返回左值</strong>：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。</li>
<li><strong>列表初始化返回值</strong>：函数可以返回花括号包围的值的列表。（<code>C++11</code>）</li>
<li><strong>主函数main的返回值</strong>：如果结尾没有<code>return</code>，编译器将隐式地插入一条返回0的<code>return</code>语句。返回0代表执行成功。</li>
</ul>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><ul>
<li><code>Type (*function (parameter_list))[dimension]</code></li>
<li>使用类型别名： <code>typedef int arrT[10];</code> 或者 <code>using arrT = int[10;]</code>，然后 <code>arrT* func() &#123;...&#125;</code></li>
<li>使用 <code>decltype</code>： <code>decltype(odd) *arrPtr(int i) &#123;...&#125;</code></li>
<li><strong>尾置返回类型</strong>： 在形参列表后面以一个<code>-&gt;</code>开始：<code>auto func(int i) -&gt; int(*)[10]</code>（<code>C++11</code>）</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><ul>
<li><strong>重载</strong>：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。</li>
<li><code>main</code>函数不能重载。</li>
<li><strong>重载和const形参</strong>：<ul>
<li>一个有顶层const的形参和没有它的函数无法区分。 <code>Record lookup(Phone* const)</code>和 <code>Record lookup(Phone*)</code>无法区分。</li>
<li>相反，是否有某个底层const形参可以区分。 <code>Record lookup(Account*)</code>和 <code>Record lookup(const Account*)</code>可以区分。</li>
</ul>
</li>
<li><strong>重载和作用域</strong>：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。</li>
</ul>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><ul>
<li><code>string screen(sz ht = 24, sz wid = 80, char backgrnd = &#39; &#39;);</code></li>
<li>一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。</li>
</ul>
<h3 id="内联（inline）函数"><a href="#内联（inline）函数" class="headerlink" title="内联（inline）函数"></a>内联（inline）函数</h3><ul>
<li>普通函数的缺点：调用函数比求解等价表达式要慢得多。</li>
<li><code>inline</code>函数可以避免函数调用的开销，可以让编译器在编译时<strong>内联地展开</strong>该函数。</li>
<li><code>inline</code>函数应该在头文件中定义。</li>
</ul>
<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><ul>
<li>指能用于常量表达式的函数。</li>
<li><code>constexpr int new_sz() &#123;return 42;&#125;</code></li>
<li>函数的返回类型及所有形参类型都要是字面值类型。</li>
<li><code>constexpr</code>函数应该在头文件中定义。</li>
</ul>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><ul>
<li><code>assert</code>预处理宏（preprocessor macro）：<code>assert(expr);</code></li>
</ul>
<p>开关调试状态：</p>
<p><code>CC -D NDEBUG main.c</code>可以定义这个变量<code>NDEBUG</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><ul>
<li>重载函数匹配的<strong>三个步骤</strong>：1.候选函数；2.可行函数；3.寻找最佳匹配。</li>
<li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。</li>
<li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。</li>
<li><strong>寻找最佳匹配</strong>：基本思想：实参类型和形参类型越接近，它们匹配地越好。</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li><strong>函数指针</strong>：是指向函数的指针。</li>
<li><code>bool (*pf)(const string &amp;, const string &amp;);</code> 注：两端的括号不可少。</li>
<li><strong>函数指针形参</strong>：<ul>
<li>形参中使用函数定义或者函数指针定义效果一样。</li>
<li>使用类型别名或者<code>decltype</code>。</li>
</ul>
</li>
<li><strong>返回指向函数的指针</strong>：1.类型别名；2.尾置返回类型。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/15/C++%20Primer%20Chapter%205%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/15/C++%20Primer%20Chapter%205%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 5 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-15 21:21:44" itemprop="dateCreated datePublished" datetime="2023-02-15T21:21:44+08:00">2023-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-22 21:37:16" itemprop="dateModified" datetime="2023-03-22T21:37:16+08:00">2023-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><ul>
<li><p><strong>空语句</strong>：只有一个单独的分号。</p>
</li>
<li><p>使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。</p>
<p>多余的空语句并非总是无害的。</p>
</li>
<li><p><strong>复合语句（块）</strong>：用花括号 <code>&#123;&#125;</code>包裹起来的语句和声明的序列。一个块就是一个作用域。</p>
</li>
<li><p>语句块不以分号作为结束。</p>
<p>空块的作用等价于空语句。</p>
</li>
</ul>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><ul>
<li><p><strong>悬垂else</strong>：用来描述在嵌套的<code>if else</code>语句中，如果<code>if</code>比<code>else</code>多时如何处理的问题。C++使用的方法是<code>else</code>匹配最近没有配对的<code>if</code>。</p>
</li>
<li><p><code>**if**</code>语句</p>
<p>if&#96;语句的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p><code>if-else</code>语句的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>

<p>其中<code>condition</code>是判断条件，可以是一个表达式或者初始化了的变量声明。<code>condition</code>必须用圆括号括起来。</p>
<ul>
<li><p>如果<code>condition</code>为真，则执行<code>statement</code>。执行完成后，程序继续执行<code>if</code>语句后面的其他语句。</p>
</li>
<li><p>如果<code>condition</code>为假，则跳过<code>statement</code>。对于简单<code>if</code>语句来说，程序直接执行<code>if</code>语句后面的其他语句；对于<code>if-else</code>语句来说，程序先执行<code>statement2</code>，再执行<code>if</code>语句后面的其他语句。</p>
</li>
</ul>
<p><code>if</code>语句可以嵌套，其中<code>else</code>与离它最近的尚未匹配的<code>if</code>相匹配。</p>
</li>
<li><p><strong><code>switch</code>语句</strong>）：<code>switch</code>语句先对括号里的表达式求值，值转换成整数类型后再与每个<code>case</code>标签（case label）的值进行比较。如果表达式的值和某个<code>case</code>标签匹配，程序从该标签之后的第一条语句开始执行，直到到达<code>switch</code>的结尾或者遇到<code>break</code>语句为止。<code>case</code>标签必须是整型常量表达式。</p>
<p>通常情况下每个<code>case</code>分支后都有<code>break</code>语句。如果确实不应该出现<code>break</code>语句，最好写一段注释说明程序的逻辑。</p>
<p>尽管<code>switch</code>语句没有强制要求在最后一个<code>case</code>标签后写上<code>break</code>，但为了安全起见，最好添加<code>break</code>。这样即使以后增加了新的<code>case</code>分支，也不用再在前面补充<code>break</code>语句了。</p>
<p><code>switch</code>语句中可以添加一个<code>default</code>标签（default label），如果没有任何一个<code>case</code>标签能匹配上<code>switch</code>表达式的值，程序将执行<code>default</code>标签后的语句。</p>
</li>
<li><p><strong><code>if</code>语句</strong> ：<code>if</code>语句的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p><code>if-else</code>语句的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>

<p>其中<code>condition</code>是判断条件，可以是一个表达式或者初始化了的变量声明。<code>condition</code>必须用圆括号括起来。</p>
<ul>
<li><p>如果<code>condition</code>为真，则执行<code>statement</code>。执行完成后，程序继续执行<code>if</code>语句后面的其他语句。</p>
</li>
<li><p>如果<code>condition</code>为假，则跳过<code>statement</code>。对于简单<code>if</code>语句来说，程序直接执行<code>if</code>语句后面的其他语句；对于<code>if-else</code>语句来说，程序先执行<code>statement2</code>，再执行<code>if</code>语句后面的其他语句。</p>
</li>
</ul>
<p><code>if</code>语句可以嵌套，其中<code>else</code>与离它最近的尚未匹配的<code>if</code>相匹配。</p>
</li>
</ul>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><ul>
<li><p><strong>while</strong>：只要<code>condition</code>的求值结果为<code>true</code>，就一直执行<code>statement</code>（通常是一个块）。<code>condition</code>不能为空，如果<code>condition</code>第一次求值就是<code>false</code>，<code>statement</code>一次都不会执行。</p>
<p>定义在<code>while</code>条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程。</p>
</li>
<li><p>当不确定到底要迭代多少次时，使用 <code>while</code>循环比较合适，比如读取输入的内容。</p>
</li>
<li><p><strong>for</strong>：<code>for</code>语句头中定义的对象只在<code>for</code>循环体内可见。 <code>for</code>语句可以省略掉 <code>init-statement</code>， <code>condition</code>和 <code>expression</code>的任何一个；<strong>甚至全部</strong>。</p>
</li>
<li><p><strong>范围for</strong>： 其中<code>expression</code>表示一个序列，拥有能返回迭代器的<code>begin</code>和<code>end</code>成员。<code>declaration</code>定义一个变量，序列中的每个元素都应该能转换成该变量的类型（可以使用<code>auto</code>）。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。每次迭代都会重新定义循环控制变量，并将其初始化为序列中的下一个值，之后才会执行<code>statement</code>。</p>
</li>
</ul>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><ul>
<li><p><strong>break</strong>：<code>break</code>语句负责终止离它最近的<code>while</code>、<code>do while</code>、<code>for</code>或者<code>switch</code>语句，并从这些语句之后的第一条语句开始继续执行。</p>
</li>
<li><p><strong>continue</strong>：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在<code>while</code>、<code>do while</code>、<code>for</code>循环的内部。</p>
</li>
<li><p>对于<code>while</code>和<code>do-while</code>语句来说，继续判断条件的值。</p>
</li>
<li><p>对于传统的<code>for</code>语句来说，继续执行<code>for</code>语句头中的第三部分，之后判断条件的值。</p>
</li>
<li><p>对于范围<code>for</code>语句来说，是用序列中的下一个元素初始化循环变量。</p>
</li>
<li><p><code>**goto**</code>语句是一种特殊的语句，在它之前有一个标识符和一个冒号。标签标识符独立于变量和其他标识符的名字，它们之间不会相互干扰。</p>
</li>
<li><p><code>goto</code>语句使程序无条件跳转到标签为<code>label</code>的语句处执行，但两者必须位于同一个函数内，同时<code>goto</code>语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。</p>
<p>建议不要在程序中使用<code>goto</code>语句，它使得程序既难理解又难修改。</p>
</li>
</ul>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><ul>
<li><strong>throw表达式</strong>：异常检测部分使用 <code>throw</code>表达式来表示它遇到了无法处理的问题。我们说 <code>throw</code>引发 <code>raise</code>了异常。</li>
<li><strong>try语句块</strong>：以 <code>try</code>关键词开始，以一个或多个 <code>catch</code>字句结束。 <code>try</code>语句块中的代码抛出的异常通常会被某个 <code>catch</code>捕获并处理。 <code>catch</code>子句也被称为<strong>异常处理代码</strong>。</li>
<li><strong>异常类</strong>：用于在 <code>throw</code>表达式和相关的 <code>catch</code>子句之间传递异常的具体信息。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/06/C++%20Primer%20Chapter%204%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/06/C++%20Primer%20Chapter%204%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 4 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-06 18:03:24" itemprop="dateCreated datePublished" datetime="2023-02-06T18:03:24+08:00">2023-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-21 18:28:35" itemprop="dateModified" datetime="2023-03-21T18:28:35+08:00">2023-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>C++定义了一元运算符和二元运算符，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</li>
<li><strong>运算对象转换</strong>：小整数类型会被提升为较大的整数类型</li>
<li><strong>重载运算符</strong>：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。</li>
<li>处理复合表达式时建议遵循以下两点：<ul>
<li><p>不确定求值顺序时，使用括号来强制让表达式的组合关系符合程序逻辑的要求。</p>
</li>
<li><p>如果表达式改变了某个运算对象的值，则在表达式的其他位置不要再使用这个运算对象。</p>
</li>
</ul>
</li>
<li><h2 id="左值和右值：-C中原意：左值可以在表达式左边，右值不能。-C-：当一个对象被用作右值的时候，用的是对象的值（内容）；-被用做左值时，用的是对象的身份（在内存中的位置）。"><a href="#左值和右值：-C中原意：左值可以在表达式左边，右值不能。-C-：当一个对象被用作右值的时候，用的是对象的值（内容）；-被用做左值时，用的是对象的身份（在内存中的位置）。" class="headerlink" title="左值和右值：  - C中原意：左值可以在表达式左边，右值不能。  - C++：当一个对象被用作右值的时候，用的是对象的值（内容）；  - 被用做左值时，用的是对象的身份（在内存中的位置）。"></a><strong>左值和右值</strong>：<br>  - C中原意：左值<strong>可以</strong>在表达式左边，右值不能。<br>  - <code>C++</code>：当一个对象被用作<strong>右值</strong>的时候，用的是对象的<strong>值</strong>（内容）；<br>  - 被用做<strong>左值</strong>时，用的是对象的<strong>身份</strong>（在内存中的位置）。</h2></li>
<li><strong>求值顺序</strong>：<code>int i = f1() + f2()</code><ul>
<li>先计算<code>f1() + f2()</code>,再计算<code>int i = f1() + f2()</code>。但是f1和f2的计算<strong>先后不确定</strong></li>
<li>但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义</li>
<li>有4种运算符明确规定了运算对象的求值顺序。<ul>
<li>逻辑与<code>&amp;&amp;</code></li>
<li>逻辑或<code>||</code></li>
<li>条件运算符<code>?:</code></li>
<li>逗号运算符<code>,</code>处理复合表达式时建议遵循以下两点：<ul>
<li><p>不确定求值顺序时，使用括号来强制让表达式的组合关系符合程序逻辑的要求。</p>
</li>
<li><p>如果表达式改变了某个运算对象的值，则在表达式的其他位置不要再使用这个运算对象。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><ul>
<li><strong>溢出</strong>：当计算的结果超出该类型所能表示的范围时就会产生溢出。</li>
<li><strong>bool类型不应该参与计算</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b=<span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> b2=-b;   <span class="comment">//仍然为true</span></span><br><span class="line"><span class="comment">//b为true，提升为对应int=1，-b=-1</span></span><br><span class="line"><span class="comment">//b2=-1≠0，所以b2仍未true</span></span><br></pre></td></tr></table></figure></li>
<li>取余运算m%n，结果符号与m相同</li>
</ul>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul>
<li><strong>短路求值</strong>：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。<strong>先左再右</strong><ul>
<li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。</li>
<li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li>
</ul>
</li>
<li>小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; text;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;s: text)&#123;</span><br><span class="line">  cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相等性测试"><a href="#相等性测试" class="headerlink" title="相等性测试"></a>相等性测试</h2><ul>
<li>测试一个算法对象或指针对象的真值，最直接的方法就是将其作为if语句的条件；<ul>
<li><code>if(val) &#123;&#125; // 如果val是任意的非0值，条件为真</code></li>
<li><code>if(!val) &#123;&#125; // 如果val是0，条件为真</code></li>
</ul>
</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li>赋值运算的<strong>返回结果时它的左侧运算对象</strong>，且是一个左值。类型也就是左侧对象的类型。</li>
<li>如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</li>
<li>赋值运算符满足<strong>右结合律</strong>，这点和其他二元运算符不一样。 <code>ival = jval = 0;</code>等价于<code>ival = (jval = 0);</code></li>
<li>赋值运算优先级比较低，使用其当条件时应该加括号。</li>
<li>复合赋值运算符，<strong>复合运算符只求值一次</strong>，普通运算符求值两次。<br>任意复合运算符op等价于<code>a = a op b;</code></li>
</ul>
<h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><ul>
<li>前置版本<code>j = ++i</code>，先加一后赋值</li>
<li>后置版本<code>j = i++</code>，先赋值后加一</li>
</ul>
<p><strong>优先使用前置</strong>版本，后置多一步储存原始值。（除非需要变化前的值）</p>
<h3 id="混用解引用和递增运算符"><a href="#混用解引用和递增运算符" class="headerlink" title="混用解引用和递增运算符"></a>混用解引用和递增运算符</h3><p><code>*iter++</code>等价于<code>*(iter++)</code>，递增优先级较高</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter!=vi.<span class="built_in">end</span>()&amp;&amp;*iter&gt;=<span class="number">0</span>)</span><br><span class="line">	cout&lt;&lt;*iter++&lt;&lt;endl;	<span class="comment">// 输出当前值，指针向前移1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>简介是一种美德</strong>，追求简洁能降低程序出错可能性</p>
</blockquote>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p><code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code></p>
<p>注意<code>.</code>运算符优先级大于<code>*</code>，所以记得加括号</p>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><ul>
<li><p>条件运算符（<code>?:</code>）允许我们把简单的<code>if-else</code>逻辑嵌入到单个表达式中去，按照如下形式：<code>cond? expr1: expr2</code></p>
</li>
<li><p>可以嵌套使用，<strong>右结合律</strong>，从右向左顺序组合</p>
<ul>
<li>&#96;&#96;&#96;c++<br>finalgrade &#x3D; (grade &gt; 90) ? “high pass”<br>: (grade &lt; 60) ? “fail” : “pass”;<br>&#x2F;&#x2F;等价于<br>finalgrade &#x3D; (grade &gt; 90) ? “high pass”<br>: （(grade &lt; 60) ? “fail” : “pass”）;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。</span><br><span class="line"></span><br><span class="line">## 位运算符</span><br><span class="line"></span><br><span class="line">用于检查和设置二进制位的功能。</span><br><span class="line"></span><br><span class="line">- 位运算符是作用于**整数类型**的运算对象。</span><br><span class="line">- 二进制位向左移（`&lt;&lt;`）或者向右移（`&gt;&gt;`），移出边界外的位就被舍弃掉了。</span><br><span class="line">- 位取反（`~`）（逐位求反）、与（`&amp;`）、或（`|`）、异或（`^`）</span><br><span class="line"></span><br><span class="line">有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试</span><br><span class="line">1UL &lt;&lt; 12;  // 代表第12个学生通过</span><br><span class="line">quiz1 |= (1UL &lt;&lt; 12);   // 将第12个学生置为已通过</span><br><span class="line">quiz1 &amp;= ~(1UL &lt;&lt; 12);  // 将第12个学生修改为未通过</span><br><span class="line">bool stu12 = quiz1 &amp; (1UL &lt;&lt; 12);   // 判断第12个学生是否通过</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>位运算符使用较少，但是重载cout、cin大家都用过</p>
</blockquote>
<p>位运算符满足左结合律，优先级介于中间，使用时尽量加括号。</p>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><ul>
<li><p>返回一条表达式或一个类型名字所占的<strong>字节数</strong>。</p>
</li>
<li><p>返回的类型是 <code>size_t</code>的常量表达式。</p>
</li>
<li><p><code>sizeof</code>并不实际计算其运算对象的值。</p>
</li>
<li><p>两种形式：</p>
<ol>
<li><code>sizeof (type)</code>，给出类型名</li>
<li><code>sizeof expr</code>，给出表达式</li>
</ol>
</li>
<li><p>可用sizeof返回数组的大小</p>
</li>
<li><p>sizeof运算符的结果部分地依赖于其作用的类型:</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li>
<li>对引用类型执行sizeof运算得到被被引用对象所占空间的大小。</li>
<li>对指针执行sizeof运算得到指针大本身所占空间的大小。</li>
<li>对解引用指针执行sizeof运算得至到指针指向的对象所占空间的大小，指针不需有效。</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ul>
</li>
</ul>
<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// sizeof(ia)返回整个数组所占空间的大小</span></span><br><span class="line"><span class="comment">// sizeof(ia)/sizeof(*ia)返回数组的大小</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia)/<span class="built_in">sizeof</span>(*ia);</span><br><span class="line"><span class="type">int</span> arr[sz];</span><br></pre></td></tr></table></figure>

<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>从左向右依次求值。</p>
<p>左侧求值结果丢弃，逗号运算符<strong>结果是右侧表达式</strong>的值。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><blockquote>
<p>设计为尽可能避免损失精度，即转换为更精细类型。</p>
</blockquote>
<ul>
<li>比 <code>int</code>类型小的整数值先提升为较大的整数类型。</li>
<li>条件中，非布尔转换成布尔。</li>
<li>初始化中，初始值转换成变量的类型。</li>
<li>算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。</li>
<li>函数调用时也会有转换。</li>
</ul>
<h4 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h4><h5 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h5><ul>
<li>常见的char、bool、short能存在int就会转换成int，否则提升为<code>unsigned int</code></li>
<li><code>wchar_t,char16_t,char32_t</code>提升为整型中<code>int,long,long long ……</code>最小的，且能容纳原类型所有可能值的类型。</li>
</ul>
<h4 id="其他转换"><a href="#其他转换" class="headerlink" title="其他转换"></a>其他转换</h4><blockquote>
<p>p143</p>
</blockquote>
<h3 id="显式类型转换（尽量避免）"><a href="#显式类型转换（尽量避免）" class="headerlink" title="显式类型转换（尽量避免）"></a>显式类型转换（尽量避免）</h3><ul>
<li><p><strong>static_cast</strong>：任何明确定义的类型转换，只要不包含底层const，都可以使用。 <code>double slope = static_cast&lt;double&gt;(j);</code></p>
</li>
<li><p><strong>dynamic_cast</strong>：支持运行时类型识别。</p>
</li>
<li><p><strong>const_cast</strong>：只能改变运算对象的底层const，一般可用于去除const性质。 <code>const char *pc; char *p = const_cast&lt;char*&gt;(pc)</code></p>
<blockquote>
<p>只有其可以改变常量属性</p>
</blockquote>
</li>
<li><p><strong>reinterpret_cast</strong>：通常为运算对象的位模式提供低层次上的重新解释。</p>
</li>
</ul>
<h4 id="旧式强制类型转换"><a href="#旧式强制类型转换" class="headerlink" title="旧式强制类型转换"></a>旧式强制类型转换</h4><p><code>type expr</code></p>
<h2 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h2><p><img src="https://cdn.jsdelivr.net/gh/ironartisan/picRepo/20220522224008-2022-05-22-22-40-08.png" alt="20220522224008-2022-05-22-22-40-08"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ironartisan/picRepo/20220522224021-2022-05-22-22-40-22.png" alt="20220522224021-2022-05-22-22-40-22"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/11/C++%20Primer%20Chapter%203%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/11/C++%20Primer%20Chapter%203%20Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 3 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-11 15:18:32" itemprop="dateCreated datePublished" datetime="2023-01-11T15:18:32+08:00">2023-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-16 20:46:56" itemprop="dateModified" datetime="2023-03-16T20:46:56+08:00">2023-03-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h2><ul>
<li>使用某个命名空间：例如 <code>using std::cin</code>表示使用命名空间<code>std</code>中的名字<code>cin</code>。</li>
<li>头文件中不应该包含<code>using</code>声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。</li>
</ul>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul>
<li>标准库类型<code>string</code>表示可变长的字符序列。</li>
<li><code>#include &lt;string&gt;</code>，然后 <code>using std::string;</code></li>
</ul>
<h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>初始化<code>string</code>对象的方式：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>string s1</code></td>
<td>默认初始化，<code>s1</code>是个空字符串</td>
</tr>
<tr>
<td><code>string s2(s1)</code></td>
<td><code>s2</code>是<code>s1</code>的副本</td>
</tr>
<tr>
<td><code>string s2 = s1</code></td>
<td>等价于<code>s2(s1)</code>，<code>s2</code>是<code>s1</code>的副本</td>
</tr>
<tr>
<td><code>string s3(&quot;value&quot;)</code></td>
<td><code>s3</code>是字面值“value”的副本，除了字面值最后的那个空字符外</td>
</tr>
<tr>
<td><code>string s3 = &quot;value&quot;</code></td>
<td>等价于<code>s3(&quot;value&quot;)</code>，<code>s3</code>是字面值”value”的副本</td>
</tr>
<tr>
<td><code>string s4(n, &#39;c&#39;)</code></td>
<td>把<code>s4</code>初始化为由连续<code>n</code>个字符<code>c</code>组成的串</td>
</tr>
</tbody></table>
<ul>
<li>拷贝初始化（copy initialization）：使用等号<code>=</code>将一个已有的对象拷贝到正在创建的对象。</li>
<li>直接初始化（direct initialization）：通过括号给对象赋值。</li>
</ul>
<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><code>string</code>的操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>os &lt;&lt; s</code></td>
<td>将<code>s</code>写到输出流<code>os</code>当中，返回<code>os</code></td>
</tr>
<tr>
<td><code>is &gt;&gt; s</code></td>
<td>从<code>is</code>中读取字符串赋给<code>s</code>，字符串以空白分割，返回<code>is</code></td>
</tr>
<tr>
<td><code>getline(is, s)</code></td>
<td>从<code>is</code>中读取一行赋给<code>s</code>，返回<code>is</code></td>
</tr>
<tr>
<td><code>s.empty()</code></td>
<td><code>s</code>为空返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>返回<code>s</code>中字符的个数</td>
</tr>
<tr>
<td><code>s[n]</code></td>
<td>返回<code>s</code>中第<code>n</code>个字符的引用，位置<code>n</code>从0计起</td>
</tr>
<tr>
<td><code>s1+s2</code></td>
<td>返回<code>s1</code>和<code>s2</code>连接后的结果</td>
</tr>
<tr>
<td><code>s1=s2</code></td>
<td>用<code>s2</code>的副本代替<code>s1</code>中原来的字符</td>
</tr>
<tr>
<td><code>s1==s2</code></td>
<td>如果<code>s1</code>和<code>s2</code>中所含的字符完全一样，则它们相等；<code>string</code>对象的相等性判断对字母的大小写敏感</td>
</tr>
<tr>
<td><code>s1!=s2</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td>
<td>利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较）</td>
</tr>
</tbody></table>
<ul>
<li>string io：<ul>
<li>执行读操作<code>&gt;&gt;</code>：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。</li>
<li><code>getline</code>：读取一整行，<strong>包括空白符</strong>。</li>
</ul>
</li>
<li><code>s.size()</code>返回的时<code>string::size_type</code>类型，记住是一个<strong>无符号</strong>类型的值，不要和<code>int</code>混用</li>
<li><code>s1+s2</code>使用时，保证至少一侧是string类型。<code>string s1 = &quot;hello&quot; + &quot;world&quot; // 错误，两侧均为字符串字面值</code></li>
<li><strong>字符串字面值和string是不同的类型。</strong></li>
</ul>
<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><ul>
<li><strong>ctype.h vs. cctype</strong>：C++修改了c的标准库，名称为去掉<code>.h</code>，前面加<code>c</code>。<blockquote>
<p>如c++版本为<code>cctype</code>，c版本为<code>ctype.h</code></p>
</blockquote>
<ul>
<li><strong>尽量使用c++版本的头文件</strong>，即<code>cctype</code></li>
</ul>
</li>
</ul>
<p><code>cctype</code>头文件中定义了一组标准函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>isalnum(c)</code></td>
<td>当<code>c</code>是字母或数字时为真</td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>当<code>c</code>是字母时为真</td>
</tr>
<tr>
<td><code>iscntrl(c)</code></td>
<td>当<code>c</code>是控制字符时为真</td>
</tr>
<tr>
<td><code>isdigit(c)</code></td>
<td>当<code>c</code>是数字时为真</td>
</tr>
<tr>
<td><code>isgraph(c)</code></td>
<td>当<code>c</code>不是空格但可以打印时为真</td>
</tr>
<tr>
<td><code>islower(c)</code></td>
<td>当<code>c</code>是小写字母时为真</td>
</tr>
<tr>
<td><code>isprint(c)</code></td>
<td>当<code>c</code>是可打印字符时为真</td>
</tr>
<tr>
<td><code>ispunct(c)</code></td>
<td>当<code>c</code>是标点符号时为真</td>
</tr>
<tr>
<td><code>isspace(c)</code></td>
<td>当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</td>
</tr>
<tr>
<td><code>isupper(c)</code></td>
<td>当<code>c</code>是大写字母时为真</td>
</tr>
<tr>
<td><code>isxdigit(c)</code></td>
<td>当<code>c</code>是十六进制数字时为真</td>
</tr>
<tr>
<td><code>tolower(c)</code></td>
<td>当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code></td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code></td>
</tr>
</tbody></table>
<ul>
<li>遍历字符串：使用<strong>范围for</strong>（range for）语句： <code>for (auto c: str)</code>，或者 <code>for (auto &amp;c: str)</code>使用引用直接改变字符串中的字符。 （C++11）</li>
<li><code>str[x]</code>,[]输入参数为<code>string::size_type</code>类型，给出<code>int</code>整型也会自动转化为该类型</li>
</ul>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>vector是一个<strong>容器</strong>，也是一个类模板；</li>
<li><code>#include &lt;vector&gt;</code> 然后 <code>using std::vector;</code></li>
<li>容器：包含其他对象。</li>
<li>类模板：本身不是类，但可以<strong>实例化instantiation</strong>出一个类。 <code>vector</code>是一个模板， <code>vector&lt;int&gt;</code>是一个类型。</li>
<li>通过将类型放在类模板名称后面的<strong>尖括号</strong>中来指定<strong>类型</strong>，如<code>vector&lt;int&gt; ivec</code>。</li>
</ul>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p>初始化<code>vector</code>对象的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>vector&lt;T&gt; v1</code></td>
<td><code>v1</code>是一个空<code>vector</code>，它潜在的元素是<code>T</code>类型的，执行默认初始化</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v2(v1)</code></td>
<td><code>v2</code>中包含有<code>v1</code>所有元素的副本</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v2 = v1</code></td>
<td>等价于<code>v2(v1)</code>，<code>v2</code>中包含<code>v1</code>所有元素的副本</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v3(n, val)</code></td>
<td><code>v3</code>包含了n个重复的元素，每个元素的值都是<code>val</code></td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v4(n)</code></td>
<td><code>v4</code>包含了n个重复地执行了值初始化的对象</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v5&#123;a, b, c...&#125;</code></td>
<td><code>v5</code>包含了初始值个数的元素，每个元素被赋予相应的初始值</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v5=&#123;a, b, c...&#125;</code></td>
<td>等价于<code>v5&#123;a, b, c...&#125;</code></td>
</tr>
</tbody></table>
<ul>
<li>列表初始化： <code>vector&lt;string&gt; v&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;</code> （C++11）</li>
</ul>
<h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><ul>
<li><code>v.push_back(e)</code> 在尾部增加元素。</li>
</ul>
<h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><p><code>vector</code>支持的操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>v.emtpy()</code></td>
<td>如果<code>v</code>不含有任何元素，返回真；否则返回假</td>
</tr>
<tr>
<td><code>v.size()</code></td>
<td>返回<code>v</code>中元素的个数</td>
</tr>
<tr>
<td><code>v.push_back(t)</code></td>
<td>向<code>v</code>的尾端添加一个值为<code>t</code>的元素</td>
</tr>
<tr>
<td><code>v[n]</code></td>
<td>返回<code>v</code>中第<code>n</code>个位置上元素的<strong>引用</strong></td>
</tr>
<tr>
<td><code>v1 = v2</code></td>
<td>用<code>v2</code>中的元素拷贝替换<code>v1</code>中的元素</td>
</tr>
<tr>
<td><code>v1 = &#123;a,b,c...&#125;</code></td>
<td>用列表中元素的拷贝替换<code>v1</code>中的元素</td>
</tr>
<tr>
<td><code>v1 == v2</code></td>
<td><code>v1</code>和<code>v2</code>相等当且仅当它们的元素数量相同且对应位置的元素值都相同</td>
</tr>
<tr>
<td><code>v1 != v2</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>, <code>&gt;=</code></td>
<td>以字典顺序进行比较</td>
</tr>
</tbody></table>
<ul>
<li>范围<code>for</code>语句内不应该改变其遍历序列的大小。</li>
<li><code>vector</code>对象（以及<code>string</code>对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。</li>
<li>两个<code>vector</code>对象相等当且仅当他们所含的元素个数相同，而且对应位置的元素也相同。</li>
</ul>
<h2 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h2><ul>
<li>所有标准库容器都可以使用迭代器。</li>
<li>类似于指针类型，迭代器也提供了对对象的间接访问。</li>
</ul>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><ul>
<li><code>vector&lt;int&gt;::iterator iter</code>。</li>
<li><code>auto b = v.begin();</code>返回指向第一个元素的迭代器。</li>
<li><code>auto e = v.end();</code>返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。</li>
<li>如果容器为空， <code>begin()</code>和 <code>end()</code>返回的是同一个迭代器，都是尾后迭代器。</li>
<li>使用解引用符<code>*</code>访问迭代器指向的元素。</li>
<li>养成使用迭代器和<code>!=</code>的习惯（泛型编程）。</li>
<li><strong>容器</strong>：可以包含其他对象；但所有的对象必须类型相同。</li>
<li><strong>迭代器（iterator）</strong>：每种标准容器都有自己的迭代器。<code>C++</code>倾向于用迭代器而不是下标遍历元素。</li>
<li><strong>const_iterator</strong>：只能读取容器内元素不能改变。</li>
<li><strong>箭头运算符</strong>： 解引用 + 成员访问，<code>it-&gt;mem</code>等价于 <code>(*it).mem</code></li>
<li><strong>谨记</strong>：但凡是使用了<strong>迭代器</strong>的循环体，都<strong>不要</strong>向迭代器所属的容器<strong>添加元素</strong>。</li>
</ul>
<p>标准容器迭代器的运算符:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>*iter</code></td>
<td>返回迭代器<code>iter</code>所指向的<strong>元素的引用</strong></td>
</tr>
<tr>
<td><code>iter-&gt;mem</code></td>
<td>等价于<code>(*iter).mem</code></td>
</tr>
<tr>
<td><code>++iter</code></td>
<td>令<code>iter</code>指示容器中的下一个元素</td>
</tr>
<tr>
<td><code>--iter</code></td>
<td>令<code>iter</code>指示容器中的上一个元素</td>
</tr>
<tr>
<td><code>iter1 == iter2</code></td>
<td>判断两个迭代器是否相等</td>
</tr>
</tbody></table>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p><code>vector</code>和<code>string</code>迭代器支持的运算：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>iter + n</code></td>
<td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。</td>
</tr>
<tr>
<td><code>iter - n</code></td>
<td>迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。</td>
</tr>
<tr>
<td><code>iter1 += n</code></td>
<td>迭代器加法的复合赋值语句，将<code>iter1</code>加n的结果赋给<code>iter1</code></td>
</tr>
<tr>
<td><code>iter1 -= n</code></td>
<td>迭代器减法的复合赋值语句，将<code>iter2</code>减n的加过赋给<code>iter1</code></td>
</tr>
<tr>
<td><code>iter1 - iter2</code></td>
<td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。</td>
</tr>
<tr>
<td><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></td>
<td>迭代器的关系运算符，如果某迭代器</td>
</tr>
</tbody></table>
<ul>
<li><strong>difference_type</strong>：保证足够大以存储任何两个迭代器对象间的距离，可正可负。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>相当于vector的低级版，<strong>长度固定</strong>。</li>
</ul>
<h3 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h3><ul>
<li>初始化：<code>char input_buffer[buffer_size];</code>，长度必须是const表达式，或者不写，让编译器自己推断。</li>
<li>定义数组必须指定数组的类型，不允许用<code>auto</code>关键字由初始值的列表推断类型，但在遍历时允许使用<code>auto</code>。</li>
<li>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</li>
<li>不允许使用一个数组为另一个内置类型的数组赋值，也不允许使用<code>vector</code>对象初始化数组，相反地，允许使用数组来初始化<code>vector</code>对象。</li>
<li>不存在引用的数组。</li>
<li>理解数组声明的含义，最好的板房是从数组的名字开始按照由内向外的顺序阅读。</li>
</ul>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ul>
<li>数组下标的类型：<code>size_t</code> 。</li>
<li>字符数组的特殊性：结尾处有一个空字符，如 <code>char a[] = &quot;hello&quot;;</code> 。</li>
<li>用数组初始化 <code>vector</code>： <code>int a[] = &#123;1,2,3,4,5&#125;; vector&lt;int&gt; v(begin(a), end(a));</code> 。</li>
</ul>
<h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><ul>
<li>使用数组时，编译器一般会把它转换成指针。</li>
<li>标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 </li>
<li><strong>指针访问数组</strong>：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。</li>
</ul>
<h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><ul>
<li>从C继承来的字符串。</li>
<li>用空字符结束（<code>\0</code>）。</li>
<li>对大多数应用来说，使用标准库 <code>string</code>比使用C风格字符串更安全、更高效。</li>
<li>获取 <code>string</code> 中的 <code>cstring</code> ： <code>const char *str = s.c_str();</code> 。</li>
</ul>
<p>C标准库String函数，定义在<code>&lt;cstring&gt;</code> 中：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><code>strlen(p)</code></td>
<td>返回<code>p</code>的长度，空字符不计算在内</td>
</tr>
<tr>
<td><code>strcmp(p1, p2)</code></td>
<td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td>
</tr>
<tr>
<td><code>strcat(p1, p2)</code></td>
<td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td>
</tr>
<tr>
<td><code>strcpy(p1, p2)</code></td>
<td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td>
</tr>
</tbody></table>
<p> <strong>尽量使用vector和迭代器，少用内置数组和指针；应尽量使用string，避免使用C风格的基于数组的字符串</strong></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><ul>
<li><p><strong>多维数组的初始化</strong>：</p>
</li>
<li><p>使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是<strong>引用</strong>类型。</p>
</li>
</ul>
<h2 id="指针vs引用"><a href="#指针vs引用" class="headerlink" title="指针vs引用"></a>指针vs引用</h2><ul>
<li>引用总是指向某个对象，定义引用时没有初始化是错的。</li>
<li>给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。</li>
</ul>
<h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><ul>
<li>定义： <code>int **ppi = &amp;pi;</code></li>
<li>解引用：<code>**ppi</code></li>
</ul>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><ul>
<li>使用 <code>new</code>和 <code>delete</code>表达和c中<code>malloc</code>和<code>free</code>类似的功能，即在堆（自由存储区）中分配存储空间。</li>
<li>定义： <code>int *pia = new int[10];</code> 10可以被一个变量替代。</li>
<li>释放： <code>delete [] pia;</code>，注意不要忘记<code>[]</code>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/20/C-Primer-Chapter-I-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HUI">
      <meta itemprop="description" content="We have a long way to go">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HUI BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/20/C-Primer-Chapter-I-Notes/" class="post-title-link" itemprop="url">C++ Primer Chapter 2 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-20 10:13:36" itemprop="dateCreated datePublished" datetime="2022-11-20T10:13:36+08:00">2022-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-16 20:45:54" itemprop="dateModified" datetime="2023-03-16T20:45:54+08:00">2023-03-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><h3 id="算数类型"><a href="#算数类型" class="headerlink" title="算数类型"></a>算数类型</h3><p>算数类型分为两类：整型、浮点型。</p>
<p><code>bool</code>类型的取值是<code>true</code>或<code>false</code>。</p>
<p>一个<code>char</code>的大小和一个机器字节一样，确保可以存放机器基本字符集中任意字符对应的数字值。<code>wchar_t</code>确保可以存放机器最大扩展字符集中的任意一个字符。</p>
<p>在整型类型大小方面，C++规定<code>short</code> ≤ <code>int</code> ≤ <code>long</code> ≤ <code>long long</code>（<code>long long</code>是C++11定义的类型）。</p>
<p>浮点型可表示单精度（single-precision）、双精度（double-precision）和扩展精度（extended-precision）值，分别对应<code>float</code>、<code>double</code>和<code>long double</code>类型。</p>
<p>除去布尔型和扩展字符型，其他整型可以分为带符号（signed）和无符号（unsigned）两种。带符号类型可以表示正数、负数和0，无符号类型只能表示大于等于0的数值。类型<code>int</code>、<code>short</code>、<code>long</code>和<code>long long</code>都是带符号的，在类型名前面添加<code>unsigned</code>可以得到对应的无符号类型，如<code>unsigned int</code>。</p>
<p>字符型分为<code>char</code>、<code>signed char</code>和<code>unsigned char</code>三种，但是表现形式只有带符号和无符号两种。类型<code>char</code>和<code>signed char</code>并不一样， <code>char</code>的具体形式由编译器（compiler）决定。</p>
<p>如何选择算数类型：</p>
<ul>
<li><p>当明确知晓数值不可能为负时，应该使用无符号类型。</p>
</li>
<li><p>使用<code>int</code>执行整数运算，如果数值超过了<code>int</code>的表示范围，应该使用<code>long long</code>类型。</p>
</li>
<li><p>在算数表达式中不要使用<code>char</code>和<code>bool</code>类型。如果需要使用一个不大的整数，应该明确指定它的类型是<code>signed char</code>还是<code>unsigned char</code>。</p>
</li>
<li><p>执行浮点数运算时建议使用<code>double</code>类型。</p>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>进行类型转换时，类型所能表示的值的范围决定了转换的过程。</p>
<ul>
<li><p>把非布尔类型的算术值赋给布尔类型时，初始值为0则结果为<code>false</code>，否则结果为<code>true</code>。</p>
</li>
<li><p>把布尔值赋给非布尔类型时，初始值为<code>false</code>则结果为0，初始值为<code>true</code>则结果为1。</p>
</li>
<li><p>把浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中的整数部分。</p>
</li>
<li><p>把整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p>
</li>
<li><p>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数（8比特大小的<code>unsigned char</code>能表示的数值总数是256）取模后的余数。</p>
</li>
<li><p>赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。</p>
</li>
</ul>
<p>避免无法预知和依赖于实现环境的行为。</p>
<p>不要混用带符号类型和无符号类型。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>以<code>0</code>开头的整数代表八进制数，以<code>0x</code>或<code>0X</code>开头的整数代表十六进制数。在C++14中，<code>0b</code>或<code>0B</code>开头的整数代表二进制数。</p>
<p>整型字面值具体的数据类型由它的值和符号决定。</p>
<p>C++14新增了单引号<code>&#39;</code>形式的数字分隔符。数字分隔符不会影响数字的值，但可以通过分隔符将数字分组，使数值读写更容易。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照书写形式，每3位分为一组</span></span><br><span class="line">std::cout &lt;&lt; <span class="number">0B</span>1<span class="number">&#x27;101</span>;   <span class="comment">// 输出&quot;13&quot;</span></span><br><span class="line">std::cout &lt;&lt; <span class="number">1&#x27;100&#x27;000</span>; <span class="comment">// 输出&quot;1100000&quot;</span></span><br></pre></td></tr></table></figure>

<p>浮点型字面值默认是一个<code>double</code>。</p>
<p>由单引号括起来的一个字符称为<code>char</code>型字面值，双引号括起来的零个或多个字符称为字符串字面值。</p>
<p>字符串字面值的类型是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符<code>&#39;\0&#39;</code>，因此字符串字面值的实际长度要比它的内容多一位。</p>
<p>转义序列：</p>
<table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">转义字符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">newline</td>
<td align="center"><code>\n</code></td>
</tr>
<tr>
<td align="center">horizontal tab</td>
<td align="center"><code>\t</code></td>
</tr>
<tr>
<td align="center">alert (bell)</td>
<td align="center"><code>\a</code></td>
</tr>
<tr>
<td align="center">vertical tab</td>
<td align="center"><code>\v</code></td>
</tr>
<tr>
<td align="center">backspace</td>
<td align="center"><code>\b</code></td>
</tr>
<tr>
<td align="center">double quote</td>
<td align="center"><code>\&quot;</code></td>
</tr>
<tr>
<td align="center">backslash</td>
<td align="center"><code>\\</code></td>
</tr>
<tr>
<td align="center">question mark</td>
<td align="center"><code>\?</code></td>
</tr>
<tr>
<td align="center">single quote</td>
<td align="center"><code>\&#39;</code></td>
</tr>
<tr>
<td align="center">carriage return</td>
<td align="center"><code>\r</code></td>
</tr>
<tr>
<td align="center">formfeed</td>
<td align="center"><code>\f</code></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;      </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\tHi!\n&quot;</span>; </span><br></pre></td></tr></table></figure>

<p>泛化转义序列的形式是<code>\x</code>后紧跟1个或多个十六进制数字，或者<code>\</code>后紧跟1个、2个或3个八进制数字，其中数字部分表示字符对应的数值。如果<code>\</code>后面跟着的八进制数字超过3个，则只有前3个数字与<code>\</code>构成转义序列。相反，<code>\x</code>要用到后面跟着的所有数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hi \x4dO\115!\n&quot;</span>; </span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\115&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    </span><br></pre></td></tr></table></figure>

<p>添加特定的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p>
<p>使用一个长整型字面值时，最好使用大写字母<code>L</code>进行标记，小写字母<code>l</code>和数字<code>1</code>容易混淆。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义的基本形式：类型说明符后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。定义时可以为一个或多个变量赋初始值（初始化）。</p>
<p>初始化不等于赋值（assignment）。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，再用一个新值来替代。</p>
<p>用花括号初始化变量称为列表初始化。当用于内置类型的变量时，如果使用了列表初始化并且初始值存在丢失信息的风险，则编译器会报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;    <span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>, d </span>= ld;      <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>如果定义变量时未指定初值，则变量被默认初始化（default initialized）。</p>
<p>对于内置类型，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化。</p>
<p>定义于函数体内的内置类型对象如果没有初始化，则其值未定义，使用该类值是一种错误的编程行为且很难调试。类的对象如果没有显式初始化，则其值由类确定。</p>
<p>建议初始化每一个内置类型的变量。</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明使得名字为程序所知。一个文件如果想使用其他地方定义的名字，则必须先包含对那个名字的声明。</p>
<p>定义负责创建与名字相关联的实体。</p>
<p>如果想声明一个变量而不定义它，就在变量名前添加关键字<code>extern</code>，并且不要显式地初始化变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// declares but does not define i</span></span><br><span class="line"><span class="type">int</span> j;      <span class="comment">// declares and defines j</span></span><br></pre></td></tr></table></figure>

<p><code>extern</code>语句如果包含了初始值就不再是声明了，而变成了定义。</p>
<p>变量能且只能被定义一次，但是可以被声明多次。</p>
<p>如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。</p>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。</p>
<p>最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。</p>
<p>作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。</p>
<p>可以用作用域操作符<code>::</code>来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p>
<p>如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<code>d</code>是变量名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival; <span class="comment">// refVal refers to (is another name for) ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;       <span class="comment">// error: a reference must be initialized</span></span><br></pre></td></tr></table></figure>

<p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化。</p>
<p>引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。</p>
<p>声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。</p>
<p>引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>与引用类似，指针也实现了对其他对象的间接访问。</p>
<ul>
<li><p>指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。</p>
</li>
<li><p>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p>
</li>
</ul>
<p>通过将声明符写成<code>*d</code>的形式来定义指针类型，其中<code>d</code>是变量名称。如果在一条语句中定义了多个指针变量，则每个量前都必须有符号<code>*</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1, *ip2;     <span class="comment">// both ip1 and ip2 are pointers to int</span></span><br><span class="line"><span class="type">double</span> dp, *dp2;    <span class="comment">// dp2 is a pointer to double; dp is a double</span></span><br></pre></td></tr></table></figure>

<p>指针存放某个对象的地址，要想获取对象的地址，需要使用取地址符<code>&amp;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br></pre></td></tr></table></figure>

<p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p>
<p>声明语句中指针的类型实际上被用于指定它所指向的对象类型。大部分情况下，指针的类型要和它指向的对象严格匹配。</p>
<p>指针的值（即地址）应属于下列状态之一：</p>
<ul>
<li><p>指向一个对象。</p>
</li>
<li><p>指向紧邻对象所占空间的下一个位置。</p>
</li>
<li><p>空指针，即指针没有指向任何对象。</p>
</li>
<li><p>无效指针，即上述情况之外的其他值。</p>
</li>
</ul>
<p>试图拷贝或以其他方式访问无效指针的值都会引发错误。</p>
<p>如果指针指向一个对象，可以使用解引用（dereference）符<code>*</code>来访问该对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br><span class="line">cout &lt;&lt; *p;     <span class="comment">// * yields the object to which p points; prints 42</span></span><br></pre></td></tr></table></figure>

<p>给解引用的结果赋值就是给指针所指向的对象赋值。</p>
<p>解引用操作仅适用于那些确实指向了某个对象的有效指针。</p>
<p>空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值<code>nullptr</code>来初始化指针。</p>
<p>旧版本程序通常使用<code>NULL</code>（预处理变量，定义于头文件<code>cstdlib</code>中，值为0）给指针赋值，但在C++11中，最好使用<code>nullptr</code>初始化空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;  <span class="comment">// equivalent to int *p1 = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;        <span class="comment">// directly initializes p2 from the literal constant 0</span></span><br><span class="line"><span class="comment">// must #include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;     <span class="comment">// equivalent to int *p3 = 0;</span></span><br></pre></td></tr></table></figure>

<p>建议初始化所有指针。</p>
<p><code>void*</code>是一种特殊的指针类型，可以存放任意对象的地址，但不能直接操作<code>void*</code>指针所指的对象。</p>
<h3 id="理解复合类型的声明："><a href="#理解复合类型的声明：" class="headerlink" title="理解复合类型的声明："></a>理解复合类型的声明：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;    <span class="comment">// pi points to an int</span></span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi;    <span class="comment">// ppi points to a pointer to an int</span></span><br></pre></td></tr></table></figure>

<p>指向指针的引用（References to Pointers）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;         <span class="comment">// p is a pointer to int</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p;    <span class="comment">// r is a reference to the pointer p</span></span><br><span class="line">r = &amp;i;         <span class="comment">// r refers to a pointer; assigning &amp;i to r makes p point to i</span></span><br><span class="line">*r = <span class="number">0</span>;         <span class="comment">// dereferencing r yields i, the object to which p points; changes i to 0</span></span><br></pre></td></tr></table></figure>

<p>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清它的真实含义。</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a><code>const</code>限定符</h2><p>在变量类型前添加关键字<code>const</code>可以创建值不能被改变的对象。<code>const</code>变量必须被初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;    <span class="comment">// input buffer size</span></span><br><span class="line">bufSize = <span class="number">512</span>;      <span class="comment">// error: attempt to write to const object</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>const</code>对象被设定成仅在文件内有效。当多个文件中出现了同名的<code>const</code>变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>如果想在多个文件间共享<code>const</code>对象：</p>
<ul>
<li><p>若<code>const</code>对象的值在编译时已经确定，则应该定义在头文件中。其他源文件包含该头文件时，不会产生重复定义错误。</p>
</li>
<li><p>若<code>const</code>对象的值直到运行时才能确定，则应该在头文件中声明，在源文件中定义。此时<code>const</code>变量的声明和定义前都应该添加<code>extern</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc defines and initializes a const that is accessible to other files</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">// file_1.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;   <span class="comment">// same bufSize as defined in file_1.cc</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a><code>const</code>的引用</h3><p>把引用绑定在<code>const</code>对象上即为对常量的引用（reference to const）。对常量的引用不能被用作修改它所绑定的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;     <span class="comment">// ok: both reference and underlying object are const</span></span><br><span class="line">r1 = <span class="number">42</span>;        <span class="comment">// error: r1 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;   <span class="comment">// error: non const reference to a const object</span></span><br></pre></td></tr></table></figure>

<p>大部分情况下，引用的类型要和与之绑定的对象严格匹配。但是有两个例外：</p>
<ul>
<li><p>初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p>
</li>
<li><p>允许为一个常量引用绑定非常量的对象、字面值或者一般表达式。</p>
</li>
</ul>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和<code>const</code></h3><p>指向常量的指针（pointer to const）不能用于修改其所指向的对象。常量对象的地址只能使用指向常量的指针来存放，但是指向常量的指针可以指向一个非常量对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;     <span class="comment">// pi is const; its value may not be changed</span></span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;          <span class="comment">// error: ptr is a plain pointer</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;   <span class="comment">// ok: cptr may point to a double that is const</span></span><br><span class="line">*cptr = <span class="number">42</span>;         <span class="comment">// error: cannot assign to *cptr</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>; <span class="comment">// dval is a double; its value can be changed</span></span><br><span class="line">cptr = &amp;dval;       <span class="comment">// ok: but can&#x27;t change dval through cptr</span></span><br></pre></td></tr></table></figure>

<p>定义语句中把<code>*</code>放在<code>const</code>之前用来说明指针本身是一个常量，常量指针（const pointer）必须初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;   <span class="comment">// curErr will always point to errNumb</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;  <span class="comment">// pip is a const pointer to a const object</span></span><br></pre></td></tr></table></figure>

<p>指针本身是常量并不代表不能通过指针修改其所指向的对象的值，能否这样做完全依赖于其指向对象的类型。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层<code>const</code></h3><p>顶层<code>const</code>表示指针本身是个常量，底层<code>const</code>（low-level const）表示指针所指的对象是一个常量。指针类型既可以是顶层<code>const</code>也可以是底层<code>const</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;     <span class="comment">// we can&#x27;t change the value of p1; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;      <span class="comment">// we cannot change ci; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;    <span class="comment">// we can change p2; const is low-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">// right-most const is top-level, left-most is not</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;      <span class="comment">// const in reference types is always low-level</span></span><br></pre></td></tr></table></figure>

<p>当执行拷贝操作时，常量是顶层<code>const</code>还是底层<code>const</code>区别明显：</p>
<ul>
<li><p>顶层<code>const</code>没有影响。拷贝操作不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量无关紧要。</p>
</li>
<li><p>拷入和拷出的对象必须具有相同的底层<code>const</code>资格。或者两个对象的数据类型可以相互转换。一般来说，非常量可以转换成常量，反之则不行。</p>
</li>
</ul>
<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a><code>constexpr</code>和常量表达式</h3><p>常量表达式（constant expressions）指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p>一个对象是否为常量表达式由它的数据类型和初始值共同决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;           <span class="comment">// max_files is a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;    <span class="comment">// limit is a constant expression</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;        <span class="comment">// staff_size is not a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">// sz is not a constant expression</span></span><br></pre></td></tr></table></figure>

<p>C++11允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<p>指针和引用都能定义成<code>constexpr</code>，但是初始值受到严格限制。<code>constexpr</code>指针的初始值必须是0、<code>nullptr</code>或者是存储在某个固定地址中的对象。</p>
<p>函数体内定义的普通变量一般并非存放在固定地址中，因此<code>constexpr</code>指针不能指向这样的变量。相反，函数体外定义的变量地址固定不变，可以用来初始化<code>constexpr</code>指针。</p>
<p>在<code>constexpr</code>声明中如果定义了一个指针，限定符<code>constexpr</code>仅对指针本身有效，与指针所指的对象无关。<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;     <span class="comment">// p是指向int的const指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *cp = &amp;i;   <span class="comment">// cp是指向const int的const指针</span></span><br></pre></td></tr></table></figure>

<p><code>const</code>和<code>constexpr</code>限定的值都是常量。但<code>constexpr</code>对象的值必须在编译期间确定，而<code>const</code>对象的值可以延迟到运行期间确定。</p>
<p>建议使用<code>constexpr</code>修饰表示数组大小的对象，因为数组的大小必须在编译期间确定且不能改变。</p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名是某种类型的同义词，传统方法是使用关键字<code>typedef</code>定义类型别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;   <span class="comment">// wages is a synonym for double</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base is a synonym for double, p for double*</span></span><br></pre></td></tr></table></figure>

<p>C++11使用关键字<code>using</code>进行别名声明（alias declaration），作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI is a synonym for Sales_item</span></span><br></pre></td></tr></table></figure>

<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a><code>auto</code>类型说明符</h3><p>C++11新增<code>auto</code>类型说明符，能让编译器自动分析表达式所属的类型。<code>auto</code>定义的变量必须有初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the type of item is deduced from the type of the result of adding val1 and val2</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2;    <span class="comment">// item initialized to the result of val1 + val2</span></span><br></pre></td></tr></table></figure>

<p>编译器推断出来的<code>auto</code>类型有时和初始值的类型并不完全一样。</p>
<ul>
<li><p>当引用被用作初始值时，编译器以引用对象的类型作为<code>auto</code>的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;     <span class="comment">// a is an int (r is an alias for i, which has type int)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>auto</code>一般会忽略顶层<code>const</code>。</p>
<p>如果希望推断出的<code>auto</code>类型是一个顶层<code>const</code>，需要显式指定<code>const auto</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// deduced type of ci is int; f has type const int</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>设置类型为<code>auto</code>的引用时，原来的初始化规则仍然适用，初始值中的顶层常量属性仍然保留。</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a><code>decltype</code>类型指示符</h3><p>C++11新增<code>decltype</code>类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;  <span class="comment">// sum has whatever type f returns</span></span><br></pre></td></tr></table></figure>

<p><code>decltype</code>处理顶层<code>const</code>和引用的方式与<code>auto</code>有些不同，如果<code>decltype</code>使用的表达式是一个变量，则<code>decltype</code>返回该变量的类型（包括顶层<code>const</code>和引用）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;     <span class="comment">// x has type const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;     <span class="comment">// y has type const int&amp; and is bound to x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;     <span class="comment">// error: z is a reference and must be initialized</span></span><br></pre></td></tr></table></figure>

<p>如果<code>decltype</code>使用的表达式不是一个变量，则<code>decltype</code>返回表达式结果对应的类型。如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则<code>decltype</code>会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。</p>
<p><code>decltype((var))</code>的结果永远是引用，而<code>decltype(var)</code>的结果只有当<code>var</code>本身是一个引用时才会是引用。</p>
<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p>
<p>类内初始值不能使用圆括号。</p>
<p>类定义的最后应该加上分号。</p>
<p>头文件（header file）通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量。</p>
<p>头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。</p>
<p>头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。<code>#define</code>指令把一个名字设定为预处理变量。<code>#ifdef</code>指令当且仅当变量已定义时为真，<code>#ifndef</code>指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>指令为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>预处理变量无视C++语言中关于作用域的规则。</p>
<p>整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。</p>
<p>头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">HUI</p>
  <div class="site-description" itemprop="description">We have a long way to go</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HUI</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

</body>
</html>
